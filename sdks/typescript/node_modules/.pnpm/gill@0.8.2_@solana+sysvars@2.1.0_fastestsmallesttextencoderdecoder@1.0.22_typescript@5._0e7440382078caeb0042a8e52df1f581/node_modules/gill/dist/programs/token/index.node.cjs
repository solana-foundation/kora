'use strict';

var token2022 = require('@solana-program/token-2022');
var system = require('@solana-program/system');
var computeBudget = require('@solana-program/compute-budget');
var kit = require('@solana/kit');
var codecs = require('@solana/codecs');

// src/programs/token/index.ts

// src/core/utils.ts
function checkedAddress(input) {
  return typeof input == "string" ? input : input.address;
}
function createTransaction({
  version,
  feePayer,
  instructions,
  latestBlockhash,
  computeUnitLimit,
  computeUnitPrice
}) {
  return kit.pipe(
    kit.createTransactionMessage({ version }),
    (tx) => {
      if (latestBlockhash) {
        tx = kit.setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx);
      }
      if (typeof feePayer !== "string" && "address" in feePayer && kit.isTransactionSigner(feePayer)) {
        return kit.setTransactionMessageFeePayerSigner(feePayer, tx);
      } else return kit.setTransactionMessageFeePayer(feePayer, tx);
    },
    (tx) => {
      if (typeof computeUnitLimit !== "undefined") {
        tx = kit.appendTransactionMessageInstruction(
          computeBudget.getSetComputeUnitLimitInstruction({ units: Number(computeUnitLimit) }),
          tx
        );
      }
      if (typeof computeUnitPrice !== "undefined") {
        tx = kit.appendTransactionMessageInstruction(
          computeBudget.getSetComputeUnitPriceInstruction({ microLamports: Number(computeUnitPrice) }),
          tx
        );
      }
      return kit.appendTransactionMessageInstructions(instructions, tx);
    }
  );
}

// src/core/accounts.ts
function getMinimumBalanceForRentExemption(space = 0) {
  const RENT = {
    /**
     * Account storage overhead for calculation of base rent. (aka the number of bytes required to store an account with no data.
     */
    ACCOUNT_STORAGE_OVERHEAD: 128n,
    /**
     * Amount of time (in years) a balance must include rent for the account to
     * be rent exempt.
     */
    DEFAULT_EXEMPTION_THRESHOLD: BigInt(Math.floor(2 * 1e3)) / 1000n,
    /**
     * Default rental rate in lamports/byte-year. This calculation is based on:
     * - 10^9 lamports per SOL
     * - $1 per SOL
     * - $0.01 per megabyte day
     * - $3.65 per megabyte year
     */
    DEFAULT_LAMPORTS_PER_BYTE_YEAR: BigInt(
      Math.floor(1e9 / 100 * 365 / (1024 * 1024))
    )
  };
  return (RENT.ACCOUNT_STORAGE_OVERHEAD + BigInt(space)) * RENT.DEFAULT_LAMPORTS_PER_BYTE_YEAR * RENT.DEFAULT_EXEMPTION_THRESHOLD / 1n;
}
function getCollectionEncoder() {
  return kit.getStructEncoder([
    ["verified", kit.getBooleanEncoder()],
    ["key", kit.getAddressEncoder()]
  ]);
}
function getCollectionDetailsEncoder() {
  return kit.getDiscriminatedUnionEncoder([
    ["V1", kit.getStructEncoder([["size", kit.getU64Encoder()]])],
    [
      "V2",
      kit.getStructEncoder([["padding", kit.fixEncoderSize(kit.getBytesEncoder(), 8)]])
    ]
  ]);
}
function getCreatorEncoder() {
  return kit.getStructEncoder([
    ["address", kit.getAddressEncoder()],
    ["verified", kit.getBooleanEncoder()],
    ["share", kit.getU8Encoder()]
  ]);
}
function getDataV2Encoder() {
  return kit.getStructEncoder([
    ["name", kit.addEncoderSizePrefix(kit.getUtf8Encoder(), kit.getU32Encoder())],
    ["symbol", kit.addEncoderSizePrefix(kit.getUtf8Encoder(), kit.getU32Encoder())],
    ["uri", kit.addEncoderSizePrefix(kit.getUtf8Encoder(), kit.getU32Encoder())],
    ["sellerFeeBasisPoints", kit.getU16Encoder()],
    ["creators", kit.getOptionEncoder(kit.getArrayEncoder(getCreatorEncoder()))],
    ["collection", kit.getOptionEncoder(getCollectionEncoder())],
    ["uses", kit.getOptionEncoder(getUsesEncoder())]
  ]);
}
function getUsesEncoder() {
  return kit.getStructEncoder([
    ["useMethod", getUseMethodEncoder()],
    ["remaining", kit.getU64Encoder()],
    ["total", kit.getU64Encoder()]
  ]);
}
var UseMethod = /* @__PURE__ */ ((UseMethod2) => {
  UseMethod2[UseMethod2["Burn"] = 0] = "Burn";
  UseMethod2[UseMethod2["Multiple"] = 1] = "Multiple";
  UseMethod2[UseMethod2["Single"] = 2] = "Single";
  return UseMethod2;
})(UseMethod || {});
function getUseMethodEncoder() {
  return kit.getEnumEncoder(UseMethod);
}

// src/programs/token-metadata/generated/programs/tokenMetadata.ts
var TOKEN_METADATA_PROGRAM_ADDRESS = "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s";
function expectAddress(value) {
  if (!value) {
    throw new Error("Expected a Address.");
  }
  if (typeof value === "object" && "address" in value) {
    return value.address;
  }
  if (Array.isArray(value)) {
    return value[0];
  }
  return value;
}
function getAccountMetaFactory(programAddress, optionalAccountStrategy) {
  return (account) => {
    if (!account.value) {
      return;
    }
    const writableRole = account.isWritable ? kit.AccountRole.WRITABLE : kit.AccountRole.READONLY;
    return Object.freeze({
      address: expectAddress(account.value),
      role: isTransactionSigner2(account.value) ? kit.upgradeRoleToSigner(writableRole) : writableRole,
      ...isTransactionSigner2(account.value) ? { signer: account.value } : {}
    });
  };
}
function isTransactionSigner2(value) {
  return !!value && typeof value === "object" && "address" in value && kit.isTransactionSigner(value);
}

// src/programs/token-metadata/generated/instructions/createMetadataAccountV3.ts
var CREATE_METADATA_ACCOUNT_V3_DISCRIMINATOR = 33;
function getCreateMetadataAccountV3InstructionDataEncoder() {
  return codecs.transformEncoder(
    codecs.getStructEncoder([
      ["discriminator", codecs.getU8Encoder()],
      ["data", getDataV2Encoder()],
      ["isMutable", codecs.getBooleanEncoder()],
      ["collectionDetails", codecs.getOptionEncoder(getCollectionDetailsEncoder())]
    ]),
    (value) => ({
      ...value,
      discriminator: CREATE_METADATA_ACCOUNT_V3_DISCRIMINATOR
    })
  );
}
function getCreateMetadataAccountV3Instruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_METADATA_PROGRAM_ADDRESS;
  const originalAccounts = {
    metadata: { value: input.metadata ?? null, isWritable: true },
    mint: { value: input.mint ?? null, isWritable: false },
    mintAuthority: { value: input.mintAuthority ?? null, isWritable: false },
    payer: { value: input.payer ?? null, isWritable: true },
    updateAuthority: {
      value: input.updateAuthority ?? null,
      isWritable: false
    },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory();
  const instruction = {
    accounts: [
      getAccountMeta(accounts.metadata),
      getAccountMeta(accounts.mint),
      getAccountMeta(accounts.mintAuthority),
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.updateAuthority),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.rent)
    ].filter((x) => x !== void 0),
    programAddress,
    data: getCreateMetadataAccountV3InstructionDataEncoder().encode(args)
  };
  return instruction;
}
async function getTokenMetadataAddress(mint) {
  return (await kit.getProgramDerivedAddress({
    programAddress: TOKEN_METADATA_PROGRAM_ADDRESS,
    seeds: [
      Buffer.from("metadata"),
      kit.getAddressEncoder().encode(TOKEN_METADATA_PROGRAM_ADDRESS),
      kit.getAddressEncoder().encode(checkedAddress(mint))
    ]
  }))[0];
}
var TOKEN_PROGRAM_ADDRESS = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
async function getAssociatedTokenAccountAddress(mint, owner, tokenProgram) {
  return (await token2022.findAssociatedTokenPda({
    mint: checkedAddress(mint),
    owner: checkedAddress(owner),
    tokenProgram: checkedTokenProgramAddress(tokenProgram)
  }))[0];
}
function parseTokenProgramAddressOrMoniker(tokenProgram) {
  if (!kit.isAddress(tokenProgram)) {
    tokenProgram = tokenProgram.toLowerCase();
  }
  switch (tokenProgram) {
    case "legacy":
    case "token":
    case TOKEN_PROGRAM_ADDRESS: {
      return TOKEN_PROGRAM_ADDRESS;
    }
    case "token22":
    case "token2022":
    case "tokenextension":
    case "tokenextensions":
    case token2022.TOKEN_2022_PROGRAM_ADDRESS: {
      return token2022.TOKEN_2022_PROGRAM_ADDRESS;
    }
    default:
      throw Error("Unsupported token program. Try 'TOKEN_PROGRAM_ADDRESS' or 'TOKEN_2022_PROGRAM_ADDRESS'");
  }
}
function assertIsSupportedTokenProgram(tokenProgram) {
  if (tokenProgram !== TOKEN_PROGRAM_ADDRESS && tokenProgram !== token2022.TOKEN_2022_PROGRAM_ADDRESS) {
    throw Error("Unsupported token program. Try 'TOKEN_PROGRAM_ADDRESS' or 'TOKEN_2022_PROGRAM_ADDRESS'");
  }
}
function checkedTokenProgramAddress(tokenProgram) {
  if (!tokenProgram) return TOKEN_PROGRAM_ADDRESS;
  tokenProgram = parseTokenProgramAddressOrMoniker(tokenProgram);
  assertIsSupportedTokenProgram(tokenProgram);
  return tokenProgram;
}

// src/programs/token/instructions/create-token.ts
function getCreateTokenInstructions(args) {
  args.tokenProgram = checkedTokenProgramAddress(args.tokenProgram);
  if (!args.decimals) args.decimals = 9;
  if (!args.mintAuthority) args.mintAuthority = args.feePayer;
  if (!args.updateAuthority) args.updateAuthority = args.feePayer;
  if (args.freezeAuthority) args.freezeAuthority = checkedAddress(args.freezeAuthority);
  if (args.tokenProgram === token2022.TOKEN_2022_PROGRAM_ADDRESS) {
    const metadataPointer = token2022.extension("MetadataPointer", {
      metadataAddress: args.mint.address,
      authority: args.updateAuthority.address
    });
    const metadataExtensionData = token2022.extension("TokenMetadata", {
      updateAuthority: args.updateAuthority.address,
      mint: args.mint.address,
      name: args.metadata.name,
      symbol: args.metadata.symbol,
      uri: args.metadata.uri,
      // todo: support token22 additional metadata
      additionalMetadata: /* @__PURE__ */ new Map()
    });
    return [
      system.getCreateAccountInstruction({
        payer: args.feePayer,
        newAccount: args.mint,
        /**
         * token22 requires only the pre-mint-initialization extensions (like metadata pointer)
         * to be the `space`. then it will extend the account's space for each applicable extension
         * */
        space: BigInt(token2022.getMintSize([metadataPointer])),
        /**
         * token22 requires the total lamport balance for all extensions,
         * including pre-initialization and post-initialization
         */
        lamports: getMinimumBalanceForRentExemption(BigInt(token2022.getMintSize([metadataPointer, metadataExtensionData]))),
        programAddress: args.tokenProgram
      }),
      token2022.getInitializeMetadataPointerInstruction({
        authority: args.mintAuthority.address,
        metadataAddress: args.metadataAddress,
        mint: args.mint.address
      }),
      token2022.getInitializeMintInstruction(
        {
          mint: args.mint.address,
          decimals: Number(args.decimals),
          mintAuthority: args.mintAuthority.address,
          freezeAuthority: args.freezeAuthority || null
        },
        {
          programAddress: args.tokenProgram
        }
      ),
      token2022.getInitializeTokenMetadataInstruction({
        metadata: args.mint.address,
        mint: args.mint.address,
        mintAuthority: args.mintAuthority,
        name: args.metadata.name,
        symbol: args.metadata.symbol,
        uri: args.metadata.uri,
        updateAuthority: args.updateAuthority.address
      })
      // todo: support token22 additional metadata by adding that instruction(s) here
    ];
  } else {
    const space = BigInt(token2022.getMintSize());
    return [
      system.getCreateAccountInstruction({
        payer: args.feePayer,
        newAccount: args.mint,
        lamports: getMinimumBalanceForRentExemption(space),
        space,
        programAddress: args.tokenProgram
      }),
      token2022.getInitializeMintInstruction(
        {
          mint: args.mint.address,
          decimals: Number(args.decimals),
          mintAuthority: args.mintAuthority.address,
          freezeAuthority: args.freezeAuthority || null
        },
        {
          programAddress: args.tokenProgram
        }
      ),
      getCreateMetadataAccountV3Instruction({
        metadata: args.metadataAddress,
        mint: args.mint.address,
        mintAuthority: args.mintAuthority,
        payer: args.feePayer,
        updateAuthority: args.updateAuthority,
        data: {
          name: args.metadata.name,
          symbol: args.metadata.symbol,
          uri: args.metadata.uri,
          sellerFeeBasisPoints: 0,
          creators: null,
          collection: null,
          uses: null
        },
        isMutable: args.metadata.isMutable,
        collectionDetails: null
      })
    ];
  }
}
function getMintTokensInstructions(args) {
  args.tokenProgram = checkedTokenProgramAddress(args.tokenProgram);
  args.mint = checkedAddress(args.mint);
  return [
    // create idempotent will gracefully fail if the ata already exists. this is the gold standard!
    token2022.getCreateAssociatedTokenIdempotentInstruction({
      owner: checkedAddress(args.destination),
      mint: args.mint,
      ata: args.ata,
      payer: args.feePayer,
      tokenProgram: args.tokenProgram
    }),
    token2022.getMintToInstruction(
      {
        mint: args.mint,
        mintAuthority: args.mintAuthority,
        token: args.ata,
        amount: args.amount
      },
      {
        programAddress: args.tokenProgram
      }
    )
  ];
}
function getTransferTokensInstructions(args) {
  args.tokenProgram = checkedTokenProgramAddress(args.tokenProgram);
  args.mint = checkedAddress(args.mint);
  return [
    // create idempotent will gracefully fail if the ata already exists. this is the gold standard!
    token2022.getCreateAssociatedTokenIdempotentInstruction({
      owner: checkedAddress(args.destination),
      mint: args.mint,
      ata: args.destinationAta,
      payer: args.feePayer,
      tokenProgram: args.tokenProgram
    }),
    token2022.getTransferInstruction(
      {
        authority: args.authority,
        source: args.sourceAta,
        destination: args.destinationAta,
        amount: args.amount
      },
      {
        programAddress: args.tokenProgram
      }
    )
  ];
}
async function buildCreateTokenTransaction(args) {
  args.tokenProgram = checkedTokenProgramAddress(args.tokenProgram);
  let metadataAddress = args.mint.address;
  if (args.tokenProgram === TOKEN_PROGRAM_ADDRESS) {
    metadataAddress = await getTokenMetadataAddress(args.mint);
    if (!args.computeUnitLimit) {
      args.computeUnitLimit = 6e4;
    }
  } else if (args.tokenProgram === token2022.TOKEN_2022_PROGRAM_ADDRESS) {
    if (!args.computeUnitLimit) {
      args.computeUnitLimit = 1e4;
    }
  }
  return createTransaction(
    (({ feePayer, version, computeUnitLimit, computeUnitPrice, latestBlockhash }) => ({
      feePayer,
      version: version || "legacy",
      computeUnitLimit,
      computeUnitPrice,
      latestBlockhash,
      instructions: getCreateTokenInstructions(
        (({
          decimals,
          mintAuthority,
          freezeAuthority,
          updateAuthority,
          metadata,
          feePayer: feePayer2,
          tokenProgram,
          mint
        }) => ({
          mint,
          feePayer: feePayer2,
          metadataAddress,
          metadata,
          decimals,
          mintAuthority,
          freezeAuthority,
          updateAuthority,
          tokenProgram
        }))(args)
      )
    }))(args)
  );
}

// src/programs/token/transactions/mint-tokens.ts
async function buildMintTokensTransaction(args) {
  args.tokenProgram = checkedTokenProgramAddress(args.tokenProgram);
  args.mint = checkedAddress(args.mint);
  if (!args.ata) {
    args.ata = await getAssociatedTokenAccountAddress(args.mint, args.destination, args.tokenProgram);
  }
  if (!args.computeUnitLimit) {
    args.computeUnitLimit = 31e3;
  }
  return createTransaction(
    (({ feePayer, version, computeUnitLimit, computeUnitPrice, latestBlockhash }) => ({
      feePayer,
      version: version || "legacy",
      computeUnitLimit,
      computeUnitPrice,
      latestBlockhash,
      instructions: getMintTokensInstructions(
        (({ tokenProgram, feePayer: feePayer2, mint, ata, mintAuthority, amount, destination }) => ({
          tokenProgram,
          feePayer: feePayer2,
          mint,
          mintAuthority,
          ata,
          amount,
          destination
        }))(args)
      )
    }))(args)
  );
}

// src/programs/token/transactions/transfer-tokens.ts
async function buildTransferTokensTransaction(args) {
  args.tokenProgram = checkedTokenProgramAddress(args.tokenProgram);
  args.mint = checkedAddress(args.mint);
  [args.destinationAta, args.sourceAta] = await Promise.all([
    !args.destinationAta ? getAssociatedTokenAccountAddress(args.mint, args.destination, args.tokenProgram) : args.destinationAta,
    !args.sourceAta ? getAssociatedTokenAccountAddress(args.mint, args.authority, args.tokenProgram) : args.sourceAta
  ]);
  if (!args.computeUnitLimit) {
    args.computeUnitLimit = 31e3;
  }
  return createTransaction(
    (({ feePayer, version, computeUnitLimit, computeUnitPrice, latestBlockhash }) => ({
      feePayer,
      version: version || "legacy",
      computeUnitLimit,
      computeUnitPrice,
      latestBlockhash,
      instructions: getTransferTokensInstructions(
        (({
          tokenProgram,
          feePayer: feePayer2,
          mint,
          amount,
          destination,
          authority,
          destinationAta,
          sourceAta
        }) => ({
          tokenProgram,
          feePayer: feePayer2,
          mint,
          amount,
          authority,
          destination,
          sourceAta,
          destinationAta
        }))(args)
      )
    }))(args)
  );
}

exports.TOKEN_PROGRAM_ADDRESS = TOKEN_PROGRAM_ADDRESS;
exports.assertIsSupportedTokenProgram = assertIsSupportedTokenProgram;
exports.buildCreateTokenTransaction = buildCreateTokenTransaction;
exports.buildMintTokensTransaction = buildMintTokensTransaction;
exports.buildTransferTokensTransaction = buildTransferTokensTransaction;
exports.checkedTokenProgramAddress = checkedTokenProgramAddress;
exports.getAssociatedTokenAccountAddress = getAssociatedTokenAccountAddress;
exports.getCreateTokenInstructions = getCreateTokenInstructions;
exports.getMintTokensInstructions = getMintTokensInstructions;
exports.getTransferTokensInstructions = getTransferTokensInstructions;
exports.parseTokenProgramAddressOrMoniker = parseTokenProgramAddressOrMoniker;
Object.keys(token2022).forEach(function (k) {
  if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () { return token2022[k]; }
  });
});
//# sourceMappingURL=index.node.cjs.map
//# sourceMappingURL=index.node.cjs.map