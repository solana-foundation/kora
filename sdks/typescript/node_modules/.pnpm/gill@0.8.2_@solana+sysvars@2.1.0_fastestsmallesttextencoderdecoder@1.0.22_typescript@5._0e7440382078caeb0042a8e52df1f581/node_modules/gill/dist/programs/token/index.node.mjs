import { getMinimumBalanceForRentExemption, createTransaction } from '../../chunk-PERRWHDA.node.mjs';
import { getCreateMetadataAccountV3Instruction, getTokenMetadataAddress } from '../../chunk-BN6CXGII.node.mjs';
import { checkedAddress } from '../../chunk-MBU5ZJWO.node.mjs';
import { findAssociatedTokenPda, TOKEN_2022_PROGRAM_ADDRESS, extension, getMintSize, getInitializeMetadataPointerInstruction, getInitializeMintInstruction, getInitializeTokenMetadataInstruction, getCreateAssociatedTokenIdempotentInstruction, getMintToInstruction, getTransferInstruction } from '@solana-program/token-2022';
export * from '@solana-program/token-2022';
import { getCreateAccountInstruction } from '@solana-program/system';
import { isAddress } from '@solana/kit';

var TOKEN_PROGRAM_ADDRESS = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
async function getAssociatedTokenAccountAddress(mint, owner, tokenProgram) {
  return (await findAssociatedTokenPda({
    mint: checkedAddress(mint),
    owner: checkedAddress(owner),
    tokenProgram: checkedTokenProgramAddress(tokenProgram)
  }))[0];
}
function parseTokenProgramAddressOrMoniker(tokenProgram) {
  if (!isAddress(tokenProgram)) {
    tokenProgram = tokenProgram.toLowerCase();
  }
  switch (tokenProgram) {
    case "legacy":
    case "token":
    case TOKEN_PROGRAM_ADDRESS: {
      return TOKEN_PROGRAM_ADDRESS;
    }
    case "token22":
    case "token2022":
    case "tokenextension":
    case "tokenextensions":
    case TOKEN_2022_PROGRAM_ADDRESS: {
      return TOKEN_2022_PROGRAM_ADDRESS;
    }
    default:
      throw Error("Unsupported token program. Try 'TOKEN_PROGRAM_ADDRESS' or 'TOKEN_2022_PROGRAM_ADDRESS'");
  }
}
function assertIsSupportedTokenProgram(tokenProgram) {
  if (tokenProgram !== TOKEN_PROGRAM_ADDRESS && tokenProgram !== TOKEN_2022_PROGRAM_ADDRESS) {
    throw Error("Unsupported token program. Try 'TOKEN_PROGRAM_ADDRESS' or 'TOKEN_2022_PROGRAM_ADDRESS'");
  }
}
function checkedTokenProgramAddress(tokenProgram) {
  if (!tokenProgram) return TOKEN_PROGRAM_ADDRESS;
  tokenProgram = parseTokenProgramAddressOrMoniker(tokenProgram);
  assertIsSupportedTokenProgram(tokenProgram);
  return tokenProgram;
}

// src/programs/token/instructions/create-token.ts
function getCreateTokenInstructions(args) {
  args.tokenProgram = checkedTokenProgramAddress(args.tokenProgram);
  if (!args.decimals) args.decimals = 9;
  if (!args.mintAuthority) args.mintAuthority = args.feePayer;
  if (!args.updateAuthority) args.updateAuthority = args.feePayer;
  if (args.freezeAuthority) args.freezeAuthority = checkedAddress(args.freezeAuthority);
  if (args.tokenProgram === TOKEN_2022_PROGRAM_ADDRESS) {
    const metadataPointer = extension("MetadataPointer", {
      metadataAddress: args.mint.address,
      authority: args.updateAuthority.address
    });
    const metadataExtensionData = extension("TokenMetadata", {
      updateAuthority: args.updateAuthority.address,
      mint: args.mint.address,
      name: args.metadata.name,
      symbol: args.metadata.symbol,
      uri: args.metadata.uri,
      // todo: support token22 additional metadata
      additionalMetadata: /* @__PURE__ */ new Map()
    });
    return [
      getCreateAccountInstruction({
        payer: args.feePayer,
        newAccount: args.mint,
        /**
         * token22 requires only the pre-mint-initialization extensions (like metadata pointer)
         * to be the `space`. then it will extend the account's space for each applicable extension
         * */
        space: BigInt(getMintSize([metadataPointer])),
        /**
         * token22 requires the total lamport balance for all extensions,
         * including pre-initialization and post-initialization
         */
        lamports: getMinimumBalanceForRentExemption(BigInt(getMintSize([metadataPointer, metadataExtensionData]))),
        programAddress: args.tokenProgram
      }),
      getInitializeMetadataPointerInstruction({
        authority: args.mintAuthority.address,
        metadataAddress: args.metadataAddress,
        mint: args.mint.address
      }),
      getInitializeMintInstruction(
        {
          mint: args.mint.address,
          decimals: Number(args.decimals),
          mintAuthority: args.mintAuthority.address,
          freezeAuthority: args.freezeAuthority || null
        },
        {
          programAddress: args.tokenProgram
        }
      ),
      getInitializeTokenMetadataInstruction({
        metadata: args.mint.address,
        mint: args.mint.address,
        mintAuthority: args.mintAuthority,
        name: args.metadata.name,
        symbol: args.metadata.symbol,
        uri: args.metadata.uri,
        updateAuthority: args.updateAuthority.address
      })
      // todo: support token22 additional metadata by adding that instruction(s) here
    ];
  } else {
    const space = BigInt(getMintSize());
    return [
      getCreateAccountInstruction({
        payer: args.feePayer,
        newAccount: args.mint,
        lamports: getMinimumBalanceForRentExemption(space),
        space,
        programAddress: args.tokenProgram
      }),
      getInitializeMintInstruction(
        {
          mint: args.mint.address,
          decimals: Number(args.decimals),
          mintAuthority: args.mintAuthority.address,
          freezeAuthority: args.freezeAuthority || null
        },
        {
          programAddress: args.tokenProgram
        }
      ),
      getCreateMetadataAccountV3Instruction({
        metadata: args.metadataAddress,
        mint: args.mint.address,
        mintAuthority: args.mintAuthority,
        payer: args.feePayer,
        updateAuthority: args.updateAuthority,
        data: {
          name: args.metadata.name,
          symbol: args.metadata.symbol,
          uri: args.metadata.uri,
          sellerFeeBasisPoints: 0,
          creators: null,
          collection: null,
          uses: null
        },
        isMutable: args.metadata.isMutable,
        collectionDetails: null
      })
    ];
  }
}
function getMintTokensInstructions(args) {
  args.tokenProgram = checkedTokenProgramAddress(args.tokenProgram);
  args.mint = checkedAddress(args.mint);
  return [
    // create idempotent will gracefully fail if the ata already exists. this is the gold standard!
    getCreateAssociatedTokenIdempotentInstruction({
      owner: checkedAddress(args.destination),
      mint: args.mint,
      ata: args.ata,
      payer: args.feePayer,
      tokenProgram: args.tokenProgram
    }),
    getMintToInstruction(
      {
        mint: args.mint,
        mintAuthority: args.mintAuthority,
        token: args.ata,
        amount: args.amount
      },
      {
        programAddress: args.tokenProgram
      }
    )
  ];
}
function getTransferTokensInstructions(args) {
  args.tokenProgram = checkedTokenProgramAddress(args.tokenProgram);
  args.mint = checkedAddress(args.mint);
  return [
    // create idempotent will gracefully fail if the ata already exists. this is the gold standard!
    getCreateAssociatedTokenIdempotentInstruction({
      owner: checkedAddress(args.destination),
      mint: args.mint,
      ata: args.destinationAta,
      payer: args.feePayer,
      tokenProgram: args.tokenProgram
    }),
    getTransferInstruction(
      {
        authority: args.authority,
        source: args.sourceAta,
        destination: args.destinationAta,
        amount: args.amount
      },
      {
        programAddress: args.tokenProgram
      }
    )
  ];
}
async function buildCreateTokenTransaction(args) {
  args.tokenProgram = checkedTokenProgramAddress(args.tokenProgram);
  let metadataAddress = args.mint.address;
  if (args.tokenProgram === TOKEN_PROGRAM_ADDRESS) {
    metadataAddress = await getTokenMetadataAddress(args.mint);
    if (!args.computeUnitLimit) {
      args.computeUnitLimit = 6e4;
    }
  } else if (args.tokenProgram === TOKEN_2022_PROGRAM_ADDRESS) {
    if (!args.computeUnitLimit) {
      args.computeUnitLimit = 1e4;
    }
  }
  return createTransaction(
    (({ feePayer, version, computeUnitLimit, computeUnitPrice, latestBlockhash }) => ({
      feePayer,
      version: version || "legacy",
      computeUnitLimit,
      computeUnitPrice,
      latestBlockhash,
      instructions: getCreateTokenInstructions(
        (({
          decimals,
          mintAuthority,
          freezeAuthority,
          updateAuthority,
          metadata,
          feePayer: feePayer2,
          tokenProgram,
          mint
        }) => ({
          mint,
          feePayer: feePayer2,
          metadataAddress,
          metadata,
          decimals,
          mintAuthority,
          freezeAuthority,
          updateAuthority,
          tokenProgram
        }))(args)
      )
    }))(args)
  );
}

// src/programs/token/transactions/mint-tokens.ts
async function buildMintTokensTransaction(args) {
  args.tokenProgram = checkedTokenProgramAddress(args.tokenProgram);
  args.mint = checkedAddress(args.mint);
  if (!args.ata) {
    args.ata = await getAssociatedTokenAccountAddress(args.mint, args.destination, args.tokenProgram);
  }
  if (!args.computeUnitLimit) {
    args.computeUnitLimit = 31e3;
  }
  return createTransaction(
    (({ feePayer, version, computeUnitLimit, computeUnitPrice, latestBlockhash }) => ({
      feePayer,
      version: version || "legacy",
      computeUnitLimit,
      computeUnitPrice,
      latestBlockhash,
      instructions: getMintTokensInstructions(
        (({ tokenProgram, feePayer: feePayer2, mint, ata, mintAuthority, amount, destination }) => ({
          tokenProgram,
          feePayer: feePayer2,
          mint,
          mintAuthority,
          ata,
          amount,
          destination
        }))(args)
      )
    }))(args)
  );
}

// src/programs/token/transactions/transfer-tokens.ts
async function buildTransferTokensTransaction(args) {
  args.tokenProgram = checkedTokenProgramAddress(args.tokenProgram);
  args.mint = checkedAddress(args.mint);
  [args.destinationAta, args.sourceAta] = await Promise.all([
    !args.destinationAta ? getAssociatedTokenAccountAddress(args.mint, args.destination, args.tokenProgram) : args.destinationAta,
    !args.sourceAta ? getAssociatedTokenAccountAddress(args.mint, args.authority, args.tokenProgram) : args.sourceAta
  ]);
  if (!args.computeUnitLimit) {
    args.computeUnitLimit = 31e3;
  }
  return createTransaction(
    (({ feePayer, version, computeUnitLimit, computeUnitPrice, latestBlockhash }) => ({
      feePayer,
      version: version || "legacy",
      computeUnitLimit,
      computeUnitPrice,
      latestBlockhash,
      instructions: getTransferTokensInstructions(
        (({
          tokenProgram,
          feePayer: feePayer2,
          mint,
          amount,
          destination,
          authority,
          destinationAta,
          sourceAta
        }) => ({
          tokenProgram,
          feePayer: feePayer2,
          mint,
          amount,
          authority,
          destination,
          sourceAta,
          destinationAta
        }))(args)
      )
    }))(args)
  );
}

export { TOKEN_PROGRAM_ADDRESS, assertIsSupportedTokenProgram, buildCreateTokenTransaction, buildMintTokensTransaction, buildTransferTokensTransaction, checkedTokenProgramAddress, getAssociatedTokenAccountAddress, getCreateTokenInstructions, getMintTokensInstructions, getTransferTokensInstructions, parseTokenProgramAddressOrMoniker };
//# sourceMappingURL=index.node.mjs.map
//# sourceMappingURL=index.node.mjs.map