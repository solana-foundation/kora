export * from '@solana-program/system';
export * from '@solana-program/address-lookup-table';
import { COMPUTE_BUDGET_PROGRAM_ADDRESS } from '@solana-program/compute-budget';
export * from '@solana-program/compute-budget';
import * as _solana_kit from '@solana/kit';
import { IInstruction, IInstructionWithData, TransactionMessage, Address, IAccountMeta, IInstructionWithAccounts, TransactionSigner, Option, OptionOrNullable, Encoder as Encoder$1, Decoder as Decoder$1, Codec as Codec$1, ReadonlyUint8Array, GetDiscriminatedUnionVariantContent, GetDiscriminatedUnionVariant, EncodedAccount, Account, MaybeEncodedAccount, MaybeAccount, fetchEncodedAccount, FetchAccountConfig, fetchEncodedAccounts, FetchAccountsConfig, WritableAccount, ReadonlyAccount, ReadonlySignerAccount, IAccountSignerMeta, WritableSignerAccount, KeyPairSigner } from '@solana/kit';
import { Encoder, Decoder, Codec, ReadonlyUint8Array as ReadonlyUint8Array$1, Option as Option$1, OptionOrNullable as OptionOrNullable$1 } from '@solana/codecs';

/**
 * Check if a given instruction is a `SetComputeUnitLimit` instruction
 */
declare function isSetComputeLimitInstruction(instruction: IInstruction): instruction is IInstruction<typeof COMPUTE_BUDGET_PROGRAM_ADDRESS> & IInstructionWithData<Uint8Array>;
/**
 * Check if a given transaction contains a `SetComputeUnitLimit` instruction
 */
declare function hasSetComputeLimitInstruction(tx: TransactionMessage): boolean;
/**
 * Check if a given instruction is a `SetComputeUnitPrice` instruction
 */
declare function isSetComputeUnitPriceInstruction(instruction: IInstruction): instruction is IInstruction<typeof COMPUTE_BUDGET_PROGRAM_ADDRESS> & IInstructionWithData<Uint8Array>;
/**
 * Check if a given transaction contains a `SetComputeUnitPrice` instruction
 */
declare function hasSetComputeUnitPriceInstruction(tx: TransactionMessage): boolean;

/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

declare const MEMO_PROGRAM_ADDRESS: Address<"MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr">;
declare enum MemoInstruction {
    AddMemo = 0
}
type ParsedMemoInstruction<TProgram extends string = "MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"> = {
    instructionType: MemoInstruction.AddMemo;
} & ParsedAddMemoInstruction<TProgram>;

/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

type AddMemoInstruction<TProgram extends string = typeof MEMO_PROGRAM_ADDRESS, TRemainingAccounts extends readonly IAccountMeta<string>[] = []> = IInstruction<TProgram> & IInstructionWithData<Uint8Array> & IInstructionWithAccounts<TRemainingAccounts>;
type AddMemoInstructionData = {
    memo: string;
};
type AddMemoInstructionDataArgs = AddMemoInstructionData;
declare function getAddMemoInstructionDataEncoder(): Encoder<AddMemoInstructionDataArgs>;
declare function getAddMemoInstructionDataDecoder(): Decoder<AddMemoInstructionData>;
declare function getAddMemoInstructionDataCodec(): Codec<AddMemoInstructionDataArgs, AddMemoInstructionData>;
type AddMemoInput = {
    memo: AddMemoInstructionDataArgs["memo"];
    signers?: Array<TransactionSigner>;
};
declare function getAddMemoInstruction<TProgramAddress extends Address = typeof MEMO_PROGRAM_ADDRESS>(input: AddMemoInput, config?: {
    programAddress?: TProgramAddress;
}): AddMemoInstruction<TProgramAddress>;
type ParsedAddMemoInstruction<TProgram extends string = typeof MEMO_PROGRAM_ADDRESS> = {
    programAddress: Address<TProgram>;
    data: AddMemoInstructionData;
};
declare function parseAddMemoInstruction<TProgram extends string>(instruction: IInstruction<TProgram> & IInstructionWithData<Uint8Array>): ParsedAddMemoInstruction<TProgram>;

/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

type AssetData = {
    name: string;
    symbol: string;
    uri: string;
    sellerFeeBasisPoints: number;
    creators: Option<Array<Creator>>;
    primarySaleHappened: boolean;
    isMutable: boolean;
    tokenStandard: TokenStandard;
    collection: Option<Collection>;
    uses: Option<Uses>;
    collectionDetails: Option<CollectionDetails>;
    ruleSet: Option<Address>;
};
type AssetDataArgs = {
    name: string;
    symbol: string;
    uri: string;
    sellerFeeBasisPoints: number;
    creators: OptionOrNullable<Array<CreatorArgs>>;
    primarySaleHappened: boolean;
    isMutable: boolean;
    tokenStandard: TokenStandardArgs;
    collection: OptionOrNullable<CollectionArgs>;
    uses: OptionOrNullable<UsesArgs>;
    collectionDetails: OptionOrNullable<CollectionDetailsArgs>;
    ruleSet: OptionOrNullable<Address>;
};
declare function getAssetDataEncoder(): Encoder$1<AssetDataArgs>;
declare function getAssetDataDecoder(): Decoder$1<AssetData>;
declare function getAssetDataCodec(): Codec$1<AssetDataArgs, AssetData>;

/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

type Collection = {
    verified: boolean;
    key: Address;
};
type CollectionArgs = Collection;
declare function getCollectionEncoder(): Encoder$1<CollectionArgs>;
declare function getCollectionDecoder(): Decoder$1<Collection>;
declare function getCollectionCodec(): Codec$1<CollectionArgs, Collection>;

/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

type CollectionDetails = {
    __kind: 'V1';
    size: bigint;
} | {
    __kind: 'V2';
    padding: ReadonlyUint8Array;
};
type CollectionDetailsArgs = {
    __kind: 'V1';
    size: number | bigint;
} | {
    __kind: 'V2';
    padding: ReadonlyUint8Array;
};
declare function getCollectionDetailsEncoder(): Encoder$1<CollectionDetailsArgs>;
declare function getCollectionDetailsDecoder(): Decoder$1<CollectionDetails>;
declare function getCollectionDetailsCodec(): Codec$1<CollectionDetailsArgs, CollectionDetails>;
declare function collectionDetails(kind: 'V1', data: GetDiscriminatedUnionVariantContent<CollectionDetailsArgs, '__kind', 'V1'>): GetDiscriminatedUnionVariant<CollectionDetailsArgs, '__kind', 'V1'>;
declare function collectionDetails(kind: 'V2', data: GetDiscriminatedUnionVariantContent<CollectionDetailsArgs, '__kind', 'V2'>): GetDiscriminatedUnionVariant<CollectionDetailsArgs, '__kind', 'V2'>;
declare function isCollectionDetails<K extends CollectionDetails['__kind']>(kind: K, value: CollectionDetails): value is CollectionDetails & {
    __kind: K;
};

/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

type CollectionDetailsToggle = {
    __kind: 'None';
} | {
    __kind: 'Clear';
} | {
    __kind: 'Set';
    fields: readonly [CollectionDetails];
};
type CollectionDetailsToggleArgs = {
    __kind: 'None';
} | {
    __kind: 'Clear';
} | {
    __kind: 'Set';
    fields: readonly [CollectionDetailsArgs];
};
declare function getCollectionDetailsToggleEncoder(): Encoder$1<CollectionDetailsToggleArgs>;
declare function getCollectionDetailsToggleDecoder(): Decoder$1<CollectionDetailsToggle>;
declare function getCollectionDetailsToggleCodec(): Codec$1<CollectionDetailsToggleArgs, CollectionDetailsToggle>;
declare function collectionDetailsToggle(kind: 'None'): GetDiscriminatedUnionVariant<CollectionDetailsToggleArgs, '__kind', 'None'>;
declare function collectionDetailsToggle(kind: 'Clear'): GetDiscriminatedUnionVariant<CollectionDetailsToggleArgs, '__kind', 'Clear'>;
declare function collectionDetailsToggle(kind: 'Set', data: GetDiscriminatedUnionVariantContent<CollectionDetailsToggleArgs, '__kind', 'Set'>['fields']): GetDiscriminatedUnionVariant<CollectionDetailsToggleArgs, '__kind', 'Set'>;
declare function isCollectionDetailsToggle<K extends CollectionDetailsToggle['__kind']>(kind: K, value: CollectionDetailsToggle): value is CollectionDetailsToggle & {
    __kind: K;
};

/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

type CollectionToggle = {
    __kind: 'None';
} | {
    __kind: 'Clear';
} | {
    __kind: 'Set';
    fields: readonly [Collection];
};
type CollectionToggleArgs = {
    __kind: 'None';
} | {
    __kind: 'Clear';
} | {
    __kind: 'Set';
    fields: readonly [CollectionArgs];
};
declare function getCollectionToggleEncoder(): Encoder$1<CollectionToggleArgs>;
declare function getCollectionToggleDecoder(): Decoder$1<CollectionToggle>;
declare function getCollectionToggleCodec(): Codec$1<CollectionToggleArgs, CollectionToggle>;
declare function collectionToggle(kind: 'None'): GetDiscriminatedUnionVariant<CollectionToggleArgs, '__kind', 'None'>;
declare function collectionToggle(kind: 'Clear'): GetDiscriminatedUnionVariant<CollectionToggleArgs, '__kind', 'Clear'>;
declare function collectionToggle(kind: 'Set', data: GetDiscriminatedUnionVariantContent<CollectionToggleArgs, '__kind', 'Set'>['fields']): GetDiscriminatedUnionVariant<CollectionToggleArgs, '__kind', 'Set'>;
declare function isCollectionToggle<K extends CollectionToggle['__kind']>(kind: K, value: CollectionToggle): value is CollectionToggle & {
    __kind: K;
};

/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

type CreateArgs = {
    __kind: 'V1';
    assetData: AssetData;
    decimals: Option<number>;
    printSupply: Option<PrintSupply>;
};
type CreateArgsArgs = {
    __kind: 'V1';
    assetData: AssetDataArgs;
    decimals: OptionOrNullable<number>;
    printSupply: OptionOrNullable<PrintSupplyArgs>;
};
declare function getCreateArgsEncoder(): Encoder$1<CreateArgsArgs>;
declare function getCreateArgsDecoder(): Decoder$1<CreateArgs>;
declare function getCreateArgsCodec(): Codec$1<CreateArgsArgs, CreateArgs>;
declare function createArgs(kind: 'V1', data: GetDiscriminatedUnionVariantContent<CreateArgsArgs, '__kind', 'V1'>): GetDiscriminatedUnionVariant<CreateArgsArgs, '__kind', 'V1'>;
declare function isCreateArgs<K extends CreateArgs['__kind']>(kind: K, value: CreateArgs): value is CreateArgs & {
    __kind: K;
};

/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

type Creator = {
    address: Address;
    verified: boolean;
    share: number;
};
type CreatorArgs = Creator;
declare function getCreatorEncoder(): Encoder$1<CreatorArgs>;
declare function getCreatorDecoder(): Decoder$1<Creator>;
declare function getCreatorCodec(): Codec$1<CreatorArgs, Creator>;

/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

type Data = {
    name: string;
    symbol: string;
    uri: string;
    sellerFeeBasisPoints: number;
    creators: Option<Array<Creator>>;
};
type DataArgs = {
    name: string;
    symbol: string;
    uri: string;
    sellerFeeBasisPoints: number;
    creators: OptionOrNullable<Array<CreatorArgs>>;
};
declare function getDataEncoder(): Encoder$1<DataArgs>;
declare function getDataDecoder(): Decoder$1<Data>;
declare function getDataCodec(): Codec$1<DataArgs, Data>;

/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

type DataV2 = {
    name: string;
    symbol: string;
    uri: string;
    sellerFeeBasisPoints: number;
    creators: Option<Array<Creator>>;
    collection: Option<Collection>;
    uses: Option<Uses>;
};
type DataV2Args = {
    name: string;
    symbol: string;
    uri: string;
    sellerFeeBasisPoints: number;
    creators: OptionOrNullable<Array<CreatorArgs>>;
    collection: OptionOrNullable<CollectionArgs>;
    uses: OptionOrNullable<UsesArgs>;
};
declare function getDataV2Encoder(): Encoder$1<DataV2Args>;
declare function getDataV2Decoder(): Decoder$1<DataV2>;
declare function getDataV2Codec(): Codec$1<DataV2Args, DataV2>;

/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

type DelegateArgs = {
    __kind: 'CollectionV1';
    authorizationData: Option<AuthorizationData>;
} | {
    __kind: 'SaleV1';
    amount: bigint;
    authorizationData: Option<AuthorizationData>;
} | {
    __kind: 'TransferV1';
    amount: bigint;
    authorizationData: Option<AuthorizationData>;
} | {
    __kind: 'DataV1';
    authorizationData: Option<AuthorizationData>;
} | {
    __kind: 'UtilityV1';
    amount: bigint;
    authorizationData: Option<AuthorizationData>;
} | {
    __kind: 'StakingV1';
    amount: bigint;
    authorizationData: Option<AuthorizationData>;
} | {
    __kind: 'StandardV1';
    amount: bigint;
} | {
    __kind: 'LockedTransferV1';
    amount: bigint;
    lockedAddress: Address;
    authorizationData: Option<AuthorizationData>;
} | {
    __kind: 'ProgrammableConfigV1';
    authorizationData: Option<AuthorizationData>;
} | {
    __kind: 'AuthorityItemV1';
    authorizationData: Option<AuthorizationData>;
} | {
    __kind: 'DataItemV1';
    authorizationData: Option<AuthorizationData>;
} | {
    __kind: 'CollectionItemV1';
    authorizationData: Option<AuthorizationData>;
} | {
    __kind: 'ProgrammableConfigItemV1';
    authorizationData: Option<AuthorizationData>;
} | {
    __kind: 'PrintDelegateV1';
    authorizationData: Option<AuthorizationData>;
};
type DelegateArgsArgs = {
    __kind: 'CollectionV1';
    authorizationData: OptionOrNullable<AuthorizationDataArgs>;
} | {
    __kind: 'SaleV1';
    amount: number | bigint;
    authorizationData: OptionOrNullable<AuthorizationDataArgs>;
} | {
    __kind: 'TransferV1';
    amount: number | bigint;
    authorizationData: OptionOrNullable<AuthorizationDataArgs>;
} | {
    __kind: 'DataV1';
    authorizationData: OptionOrNullable<AuthorizationDataArgs>;
} | {
    __kind: 'UtilityV1';
    amount: number | bigint;
    authorizationData: OptionOrNullable<AuthorizationDataArgs>;
} | {
    __kind: 'StakingV1';
    amount: number | bigint;
    authorizationData: OptionOrNullable<AuthorizationDataArgs>;
} | {
    __kind: 'StandardV1';
    amount: number | bigint;
} | {
    __kind: 'LockedTransferV1';
    amount: number | bigint;
    lockedAddress: Address;
    authorizationData: OptionOrNullable<AuthorizationDataArgs>;
} | {
    __kind: 'ProgrammableConfigV1';
    authorizationData: OptionOrNullable<AuthorizationDataArgs>;
} | {
    __kind: 'AuthorityItemV1';
    authorizationData: OptionOrNullable<AuthorizationDataArgs>;
} | {
    __kind: 'DataItemV1';
    authorizationData: OptionOrNullable<AuthorizationDataArgs>;
} | {
    __kind: 'CollectionItemV1';
    authorizationData: OptionOrNullable<AuthorizationDataArgs>;
} | {
    __kind: 'ProgrammableConfigItemV1';
    authorizationData: OptionOrNullable<AuthorizationDataArgs>;
} | {
    __kind: 'PrintDelegateV1';
    authorizationData: OptionOrNullable<AuthorizationDataArgs>;
};
declare function getDelegateArgsEncoder(): Encoder$1<DelegateArgsArgs>;
declare function getDelegateArgsDecoder(): Decoder$1<DelegateArgs>;
declare function getDelegateArgsCodec(): Codec$1<DelegateArgsArgs, DelegateArgs>;
declare function delegateArgs(kind: 'CollectionV1', data: GetDiscriminatedUnionVariantContent<DelegateArgsArgs, '__kind', 'CollectionV1'>): GetDiscriminatedUnionVariant<DelegateArgsArgs, '__kind', 'CollectionV1'>;
declare function delegateArgs(kind: 'SaleV1', data: GetDiscriminatedUnionVariantContent<DelegateArgsArgs, '__kind', 'SaleV1'>): GetDiscriminatedUnionVariant<DelegateArgsArgs, '__kind', 'SaleV1'>;
declare function delegateArgs(kind: 'TransferV1', data: GetDiscriminatedUnionVariantContent<DelegateArgsArgs, '__kind', 'TransferV1'>): GetDiscriminatedUnionVariant<DelegateArgsArgs, '__kind', 'TransferV1'>;
declare function delegateArgs(kind: 'DataV1', data: GetDiscriminatedUnionVariantContent<DelegateArgsArgs, '__kind', 'DataV1'>): GetDiscriminatedUnionVariant<DelegateArgsArgs, '__kind', 'DataV1'>;
declare function delegateArgs(kind: 'UtilityV1', data: GetDiscriminatedUnionVariantContent<DelegateArgsArgs, '__kind', 'UtilityV1'>): GetDiscriminatedUnionVariant<DelegateArgsArgs, '__kind', 'UtilityV1'>;
declare function delegateArgs(kind: 'StakingV1', data: GetDiscriminatedUnionVariantContent<DelegateArgsArgs, '__kind', 'StakingV1'>): GetDiscriminatedUnionVariant<DelegateArgsArgs, '__kind', 'StakingV1'>;
declare function delegateArgs(kind: 'StandardV1', data: GetDiscriminatedUnionVariantContent<DelegateArgsArgs, '__kind', 'StandardV1'>): GetDiscriminatedUnionVariant<DelegateArgsArgs, '__kind', 'StandardV1'>;
declare function delegateArgs(kind: 'LockedTransferV1', data: GetDiscriminatedUnionVariantContent<DelegateArgsArgs, '__kind', 'LockedTransferV1'>): GetDiscriminatedUnionVariant<DelegateArgsArgs, '__kind', 'LockedTransferV1'>;
declare function delegateArgs(kind: 'ProgrammableConfigV1', data: GetDiscriminatedUnionVariantContent<DelegateArgsArgs, '__kind', 'ProgrammableConfigV1'>): GetDiscriminatedUnionVariant<DelegateArgsArgs, '__kind', 'ProgrammableConfigV1'>;
declare function delegateArgs(kind: 'AuthorityItemV1', data: GetDiscriminatedUnionVariantContent<DelegateArgsArgs, '__kind', 'AuthorityItemV1'>): GetDiscriminatedUnionVariant<DelegateArgsArgs, '__kind', 'AuthorityItemV1'>;
declare function delegateArgs(kind: 'DataItemV1', data: GetDiscriminatedUnionVariantContent<DelegateArgsArgs, '__kind', 'DataItemV1'>): GetDiscriminatedUnionVariant<DelegateArgsArgs, '__kind', 'DataItemV1'>;
declare function delegateArgs(kind: 'CollectionItemV1', data: GetDiscriminatedUnionVariantContent<DelegateArgsArgs, '__kind', 'CollectionItemV1'>): GetDiscriminatedUnionVariant<DelegateArgsArgs, '__kind', 'CollectionItemV1'>;
declare function delegateArgs(kind: 'ProgrammableConfigItemV1', data: GetDiscriminatedUnionVariantContent<DelegateArgsArgs, '__kind', 'ProgrammableConfigItemV1'>): GetDiscriminatedUnionVariant<DelegateArgsArgs, '__kind', 'ProgrammableConfigItemV1'>;
declare function delegateArgs(kind: 'PrintDelegateV1', data: GetDiscriminatedUnionVariantContent<DelegateArgsArgs, '__kind', 'PrintDelegateV1'>): GetDiscriminatedUnionVariant<DelegateArgsArgs, '__kind', 'PrintDelegateV1'>;
declare function isDelegateArgs<K extends DelegateArgs['__kind']>(kind: K, value: DelegateArgs): value is DelegateArgs & {
    __kind: K;
};

/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

type EscrowAuthority = {
    __kind: 'TokenOwner';
} | {
    __kind: 'Creator';
    fields: readonly [Address];
};
type EscrowAuthorityArgs = EscrowAuthority;
declare function getEscrowAuthorityEncoder(): Encoder$1<EscrowAuthorityArgs>;
declare function getEscrowAuthorityDecoder(): Decoder$1<EscrowAuthority>;
declare function getEscrowAuthorityCodec(): Codec$1<EscrowAuthorityArgs, EscrowAuthority>;
declare function escrowAuthority(kind: 'TokenOwner'): GetDiscriminatedUnionVariant<EscrowAuthorityArgs, '__kind', 'TokenOwner'>;
declare function escrowAuthority(kind: 'Creator', data: GetDiscriminatedUnionVariantContent<EscrowAuthorityArgs, '__kind', 'Creator'>['fields']): GetDiscriminatedUnionVariant<EscrowAuthorityArgs, '__kind', 'Creator'>;
declare function isEscrowAuthority<K extends EscrowAuthority['__kind']>(kind: K, value: EscrowAuthority): value is EscrowAuthority & {
    __kind: K;
};

/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

declare enum Key {
    Uninitialized = 0,
    EditionV1 = 1,
    MasterEditionV1 = 2,
    ReservationListV1 = 3,
    MetadataV1 = 4,
    ReservationListV2 = 5,
    MasterEditionV2 = 6,
    EditionMarker = 7,
    UseAuthorityRecord = 8,
    CollectionAuthorityRecord = 9,
    TokenOwnedEscrow = 10,
    TokenRecord = 11,
    MetadataDelegate = 12,
    EditionMarkerV2 = 13,
    HolderDelegate = 14
}
type KeyArgs = Key;
declare function getKeyEncoder(): Encoder$1<KeyArgs>;
declare function getKeyDecoder(): Decoder$1<Key>;
declare function getKeyCodec(): Codec$1<KeyArgs, Key>;

/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

type MintArgs = {
    __kind: 'V1';
    amount: bigint;
    authorizationData: Option<AuthorizationData>;
};
type MintArgsArgs = {
    __kind: 'V1';
    amount: number | bigint;
    authorizationData: OptionOrNullable<AuthorizationDataArgs>;
};
declare function getMintArgsEncoder(): Encoder$1<MintArgsArgs>;
declare function getMintArgsDecoder(): Decoder$1<MintArgs>;
declare function getMintArgsCodec(): Codec$1<MintArgsArgs, MintArgs>;
declare function mintArgs(kind: 'V1', data: GetDiscriminatedUnionVariantContent<MintArgsArgs, '__kind', 'V1'>): GetDiscriminatedUnionVariant<MintArgsArgs, '__kind', 'V1'>;
declare function isMintArgs<K extends MintArgs['__kind']>(kind: K, value: MintArgs): value is MintArgs & {
    __kind: K;
};

/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

type Payload = {
    map: Map<string, PayloadType>;
};
type PayloadArgs = {
    map: Map<string, PayloadTypeArgs>;
};
declare function getPayloadEncoder(): Encoder$1<PayloadArgs>;
declare function getPayloadDecoder(): Decoder$1<Payload>;
declare function getPayloadCodec(): Codec$1<PayloadArgs, Payload>;

/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

type ProgrammableConfig = {
    __kind: 'V1';
    ruleSet: Option<Address>;
};
type ProgrammableConfigArgs = {
    __kind: 'V1';
    ruleSet: OptionOrNullable<Address>;
};
declare function getProgrammableConfigEncoder(): Encoder$1<ProgrammableConfigArgs>;
declare function getProgrammableConfigDecoder(): Decoder$1<ProgrammableConfig>;
declare function getProgrammableConfigCodec(): Codec$1<ProgrammableConfigArgs, ProgrammableConfig>;
declare function programmableConfig(kind: 'V1', data: GetDiscriminatedUnionVariantContent<ProgrammableConfigArgs, '__kind', 'V1'>): GetDiscriminatedUnionVariant<ProgrammableConfigArgs, '__kind', 'V1'>;
declare function isProgrammableConfig<K extends ProgrammableConfig['__kind']>(kind: K, value: ProgrammableConfig): value is ProgrammableConfig & {
    __kind: K;
};

/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

type Reservation = {
    address: Address;
    spotsRemaining: bigint;
    totalSpots: bigint;
};
type ReservationArgs = {
    address: Address;
    spotsRemaining: number | bigint;
    totalSpots: number | bigint;
};
declare function getReservationEncoder(): Encoder$1<ReservationArgs>;
declare function getReservationDecoder(): Decoder$1<Reservation>;
declare function getReservationCodec(): Codec$1<ReservationArgs, Reservation>;

/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

declare enum TokenStandard {
    NonFungible = 0,
    FungibleAsset = 1,
    Fungible = 2,
    NonFungibleEdition = 3,
    ProgrammableNonFungible = 4,
    ProgrammableNonFungibleEdition = 5
}
type TokenStandardArgs = TokenStandard;
declare function getTokenStandardEncoder(): Encoder$1<TokenStandardArgs>;
declare function getTokenStandardDecoder(): Decoder$1<TokenStandard>;
declare function getTokenStandardCodec(): Codec$1<TokenStandardArgs, TokenStandard>;

/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

type UpdateArgs = {
    __kind: 'V1';
    newUpdateAuthority: Option<Address>;
    data: Option<Data>;
    primarySaleHappened: Option<boolean>;
    isMutable: Option<boolean>;
    collection: CollectionToggle;
    collectionDetails: CollectionDetailsToggle;
    uses: UsesToggle;
    ruleSet: RuleSetToggle;
    authorizationData: Option<AuthorizationData>;
} | {
    __kind: 'AsUpdateAuthorityV2';
    newUpdateAuthority: Option<Address>;
    data: Option<Data>;
    primarySaleHappened: Option<boolean>;
    isMutable: Option<boolean>;
    collection: CollectionToggle;
    collectionDetails: CollectionDetailsToggle;
    uses: UsesToggle;
    ruleSet: RuleSetToggle;
    tokenStandard: Option<TokenStandard>;
    authorizationData: Option<AuthorizationData>;
} | {
    __kind: 'AsAuthorityItemDelegateV2';
    newUpdateAuthority: Option<Address>;
    primarySaleHappened: Option<boolean>;
    isMutable: Option<boolean>;
    tokenStandard: Option<TokenStandard>;
    authorizationData: Option<AuthorizationData>;
} | {
    __kind: 'AsCollectionDelegateV2';
    collection: CollectionToggle;
    authorizationData: Option<AuthorizationData>;
} | {
    __kind: 'AsDataDelegateV2';
    data: Option<Data>;
    authorizationData: Option<AuthorizationData>;
} | {
    __kind: 'AsProgrammableConfigDelegateV2';
    ruleSet: RuleSetToggle;
    authorizationData: Option<AuthorizationData>;
} | {
    __kind: 'AsDataItemDelegateV2';
    data: Option<Data>;
    authorizationData: Option<AuthorizationData>;
} | {
    __kind: 'AsCollectionItemDelegateV2';
    collection: CollectionToggle;
    authorizationData: Option<AuthorizationData>;
} | {
    __kind: 'AsProgrammableConfigItemDelegateV2';
    ruleSet: RuleSetToggle;
    authorizationData: Option<AuthorizationData>;
};
type UpdateArgsArgs = {
    __kind: 'V1';
    newUpdateAuthority: OptionOrNullable<Address>;
    data: OptionOrNullable<DataArgs>;
    primarySaleHappened: OptionOrNullable<boolean>;
    isMutable: OptionOrNullable<boolean>;
    collection: CollectionToggleArgs;
    collectionDetails: CollectionDetailsToggleArgs;
    uses: UsesToggleArgs;
    ruleSet: RuleSetToggleArgs;
    authorizationData: OptionOrNullable<AuthorizationDataArgs>;
} | {
    __kind: 'AsUpdateAuthorityV2';
    newUpdateAuthority: OptionOrNullable<Address>;
    data: OptionOrNullable<DataArgs>;
    primarySaleHappened: OptionOrNullable<boolean>;
    isMutable: OptionOrNullable<boolean>;
    collection: CollectionToggleArgs;
    collectionDetails: CollectionDetailsToggleArgs;
    uses: UsesToggleArgs;
    ruleSet: RuleSetToggleArgs;
    tokenStandard: OptionOrNullable<TokenStandardArgs>;
    authorizationData: OptionOrNullable<AuthorizationDataArgs>;
} | {
    __kind: 'AsAuthorityItemDelegateV2';
    newUpdateAuthority: OptionOrNullable<Address>;
    primarySaleHappened: OptionOrNullable<boolean>;
    isMutable: OptionOrNullable<boolean>;
    tokenStandard: OptionOrNullable<TokenStandardArgs>;
    authorizationData: OptionOrNullable<AuthorizationDataArgs>;
} | {
    __kind: 'AsCollectionDelegateV2';
    collection: CollectionToggleArgs;
    authorizationData: OptionOrNullable<AuthorizationDataArgs>;
} | {
    __kind: 'AsDataDelegateV2';
    data: OptionOrNullable<DataArgs>;
    authorizationData: OptionOrNullable<AuthorizationDataArgs>;
} | {
    __kind: 'AsProgrammableConfigDelegateV2';
    ruleSet: RuleSetToggleArgs;
    authorizationData: OptionOrNullable<AuthorizationDataArgs>;
} | {
    __kind: 'AsDataItemDelegateV2';
    data: OptionOrNullable<DataArgs>;
    authorizationData: OptionOrNullable<AuthorizationDataArgs>;
} | {
    __kind: 'AsCollectionItemDelegateV2';
    collection: CollectionToggleArgs;
    authorizationData: OptionOrNullable<AuthorizationDataArgs>;
} | {
    __kind: 'AsProgrammableConfigItemDelegateV2';
    ruleSet: RuleSetToggleArgs;
    authorizationData: OptionOrNullable<AuthorizationDataArgs>;
};
declare function getUpdateArgsEncoder(): Encoder$1<UpdateArgsArgs>;
declare function getUpdateArgsDecoder(): Decoder$1<UpdateArgs>;
declare function getUpdateArgsCodec(): Codec$1<UpdateArgsArgs, UpdateArgs>;
declare function updateArgs(kind: 'V1', data: GetDiscriminatedUnionVariantContent<UpdateArgsArgs, '__kind', 'V1'>): GetDiscriminatedUnionVariant<UpdateArgsArgs, '__kind', 'V1'>;
declare function updateArgs(kind: 'AsUpdateAuthorityV2', data: GetDiscriminatedUnionVariantContent<UpdateArgsArgs, '__kind', 'AsUpdateAuthorityV2'>): GetDiscriminatedUnionVariant<UpdateArgsArgs, '__kind', 'AsUpdateAuthorityV2'>;
declare function updateArgs(kind: 'AsAuthorityItemDelegateV2', data: GetDiscriminatedUnionVariantContent<UpdateArgsArgs, '__kind', 'AsAuthorityItemDelegateV2'>): GetDiscriminatedUnionVariant<UpdateArgsArgs, '__kind', 'AsAuthorityItemDelegateV2'>;
declare function updateArgs(kind: 'AsCollectionDelegateV2', data: GetDiscriminatedUnionVariantContent<UpdateArgsArgs, '__kind', 'AsCollectionDelegateV2'>): GetDiscriminatedUnionVariant<UpdateArgsArgs, '__kind', 'AsCollectionDelegateV2'>;
declare function updateArgs(kind: 'AsDataDelegateV2', data: GetDiscriminatedUnionVariantContent<UpdateArgsArgs, '__kind', 'AsDataDelegateV2'>): GetDiscriminatedUnionVariant<UpdateArgsArgs, '__kind', 'AsDataDelegateV2'>;
declare function updateArgs(kind: 'AsProgrammableConfigDelegateV2', data: GetDiscriminatedUnionVariantContent<UpdateArgsArgs, '__kind', 'AsProgrammableConfigDelegateV2'>): GetDiscriminatedUnionVariant<UpdateArgsArgs, '__kind', 'AsProgrammableConfigDelegateV2'>;
declare function updateArgs(kind: 'AsDataItemDelegateV2', data: GetDiscriminatedUnionVariantContent<UpdateArgsArgs, '__kind', 'AsDataItemDelegateV2'>): GetDiscriminatedUnionVariant<UpdateArgsArgs, '__kind', 'AsDataItemDelegateV2'>;
declare function updateArgs(kind: 'AsCollectionItemDelegateV2', data: GetDiscriminatedUnionVariantContent<UpdateArgsArgs, '__kind', 'AsCollectionItemDelegateV2'>): GetDiscriminatedUnionVariant<UpdateArgsArgs, '__kind', 'AsCollectionItemDelegateV2'>;
declare function updateArgs(kind: 'AsProgrammableConfigItemDelegateV2', data: GetDiscriminatedUnionVariantContent<UpdateArgsArgs, '__kind', 'AsProgrammableConfigItemDelegateV2'>): GetDiscriminatedUnionVariant<UpdateArgsArgs, '__kind', 'AsProgrammableConfigItemDelegateV2'>;
declare function isUpdateArgs<K extends UpdateArgs['__kind']>(kind: K, value: UpdateArgs): value is UpdateArgs & {
    __kind: K;
};

/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

type Uses = {
    useMethod: UseMethod;
    remaining: bigint;
    total: bigint;
};
type UsesArgs = {
    useMethod: UseMethodArgs;
    remaining: number | bigint;
    total: number | bigint;
};
declare function getUsesEncoder(): Encoder$1<UsesArgs>;
declare function getUsesDecoder(): Decoder$1<Uses>;
declare function getUsesCodec(): Codec$1<UsesArgs, Uses>;

/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

declare enum UseMethod {
    Burn = 0,
    Multiple = 1,
    Single = 2
}
type UseMethodArgs = UseMethod;
declare function getUseMethodEncoder(): Encoder$1<UseMethodArgs>;
declare function getUseMethodDecoder(): Decoder$1<UseMethod>;
declare function getUseMethodCodec(): Codec$1<UseMethodArgs, UseMethod>;

/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

type UsesToggle = {
    __kind: 'None';
} | {
    __kind: 'Clear';
} | {
    __kind: 'Set';
    fields: readonly [Uses];
};
type UsesToggleArgs = {
    __kind: 'None';
} | {
    __kind: 'Clear';
} | {
    __kind: 'Set';
    fields: readonly [UsesArgs];
};
declare function getUsesToggleEncoder(): Encoder$1<UsesToggleArgs>;
declare function getUsesToggleDecoder(): Decoder$1<UsesToggle>;
declare function getUsesToggleCodec(): Codec$1<UsesToggleArgs, UsesToggle>;
declare function usesToggle(kind: 'None'): GetDiscriminatedUnionVariant<UsesToggleArgs, '__kind', 'None'>;
declare function usesToggle(kind: 'Clear'): GetDiscriminatedUnionVariant<UsesToggleArgs, '__kind', 'Clear'>;
declare function usesToggle(kind: 'Set', data: GetDiscriminatedUnionVariantContent<UsesToggleArgs, '__kind', 'Set'>['fields']): GetDiscriminatedUnionVariant<UsesToggleArgs, '__kind', 'Set'>;
declare function isUsesToggle<K extends UsesToggle['__kind']>(kind: K, value: UsesToggle): value is UsesToggle & {
    __kind: K;
};

/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

type RuleSetToggle = {
    __kind: 'None';
} | {
    __kind: 'Clear';
} | {
    __kind: 'Set';
    fields: readonly [Address];
};
type RuleSetToggleArgs = RuleSetToggle;
declare function getRuleSetToggleEncoder(): Encoder$1<RuleSetToggleArgs>;
declare function getRuleSetToggleDecoder(): Decoder$1<RuleSetToggle>;
declare function getRuleSetToggleCodec(): Codec$1<RuleSetToggleArgs, RuleSetToggle>;
declare function ruleSetToggle(kind: 'None'): GetDiscriminatedUnionVariant<RuleSetToggleArgs, '__kind', 'None'>;
declare function ruleSetToggle(kind: 'Clear'): GetDiscriminatedUnionVariant<RuleSetToggleArgs, '__kind', 'Clear'>;
declare function ruleSetToggle(kind: 'Set', data: GetDiscriminatedUnionVariantContent<RuleSetToggleArgs, '__kind', 'Set'>['fields']): GetDiscriminatedUnionVariant<RuleSetToggleArgs, '__kind', 'Set'>;
declare function isRuleSetToggle<K extends RuleSetToggle['__kind']>(kind: K, value: RuleSetToggle): value is RuleSetToggle & {
    __kind: K;
};

/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

type AuthorizationData = {
    payload: Payload;
};
type AuthorizationDataArgs = {
    payload: PayloadArgs;
};
declare function getAuthorizationDataEncoder(): Encoder$1<AuthorizationDataArgs>;
declare function getAuthorizationDataDecoder(): Decoder$1<AuthorizationData>;
declare function getAuthorizationDataCodec(): Codec$1<AuthorizationDataArgs, AuthorizationData>;

/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

type PayloadType = {
    __kind: 'Pubkey';
    fields: readonly [Address];
} | {
    __kind: 'Seeds';
    fields: readonly [SeedsVec];
} | {
    __kind: 'MerkleProof';
    fields: readonly [ProofInfo];
} | {
    __kind: 'Number';
    fields: readonly [bigint];
};
type PayloadTypeArgs = {
    __kind: 'Pubkey';
    fields: readonly [Address];
} | {
    __kind: 'Seeds';
    fields: readonly [SeedsVecArgs];
} | {
    __kind: 'MerkleProof';
    fields: readonly [ProofInfoArgs];
} | {
    __kind: 'Number';
    fields: readonly [number | bigint];
};
declare function getPayloadTypeEncoder(): Encoder$1<PayloadTypeArgs>;
declare function getPayloadTypeDecoder(): Decoder$1<PayloadType>;
declare function getPayloadTypeCodec(): Codec$1<PayloadTypeArgs, PayloadType>;
declare function payloadType(kind: 'Pubkey', data: GetDiscriminatedUnionVariantContent<PayloadTypeArgs, '__kind', 'Pubkey'>['fields']): GetDiscriminatedUnionVariant<PayloadTypeArgs, '__kind', 'Pubkey'>;
declare function payloadType(kind: 'Seeds', data: GetDiscriminatedUnionVariantContent<PayloadTypeArgs, '__kind', 'Seeds'>['fields']): GetDiscriminatedUnionVariant<PayloadTypeArgs, '__kind', 'Seeds'>;
declare function payloadType(kind: 'MerkleProof', data: GetDiscriminatedUnionVariantContent<PayloadTypeArgs, '__kind', 'MerkleProof'>['fields']): GetDiscriminatedUnionVariant<PayloadTypeArgs, '__kind', 'MerkleProof'>;
declare function payloadType(kind: 'Number', data: GetDiscriminatedUnionVariantContent<PayloadTypeArgs, '__kind', 'Number'>['fields']): GetDiscriminatedUnionVariant<PayloadTypeArgs, '__kind', 'Number'>;
declare function isPayloadType<K extends PayloadType['__kind']>(kind: K, value: PayloadType): value is PayloadType & {
    __kind: K;
};

/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

type SeedsVec = {
    seeds: Array<ReadonlyUint8Array>;
};
type SeedsVecArgs = SeedsVec;
declare function getSeedsVecEncoder(): Encoder$1<SeedsVecArgs>;
declare function getSeedsVecDecoder(): Decoder$1<SeedsVec>;
declare function getSeedsVecCodec(): Codec$1<SeedsVecArgs, SeedsVec>;

/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

type ProofInfo = {
    proof: Array<ReadonlyUint8Array>;
};
type ProofInfoArgs = ProofInfo;
declare function getProofInfoEncoder(): Encoder$1<ProofInfoArgs>;
declare function getProofInfoDecoder(): Decoder$1<ProofInfo>;
declare function getProofInfoCodec(): Codec$1<ProofInfoArgs, ProofInfo>;

/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

type PrintSupply = {
    __kind: 'Zero';
} | {
    __kind: 'Limited';
    fields: readonly [bigint];
} | {
    __kind: 'Unlimited';
};
type PrintSupplyArgs = {
    __kind: 'Zero';
} | {
    __kind: 'Limited';
    fields: readonly [number | bigint];
} | {
    __kind: 'Unlimited';
};
declare function getPrintSupplyEncoder(): Encoder$1<PrintSupplyArgs>;
declare function getPrintSupplyDecoder(): Decoder$1<PrintSupply>;
declare function getPrintSupplyCodec(): Codec$1<PrintSupplyArgs, PrintSupply>;
declare function printSupply(kind: 'Zero'): GetDiscriminatedUnionVariant<PrintSupplyArgs, '__kind', 'Zero'>;
declare function printSupply(kind: 'Limited', data: GetDiscriminatedUnionVariantContent<PrintSupplyArgs, '__kind', 'Limited'>['fields']): GetDiscriminatedUnionVariant<PrintSupplyArgs, '__kind', 'Limited'>;
declare function printSupply(kind: 'Unlimited'): GetDiscriminatedUnionVariant<PrintSupplyArgs, '__kind', 'Unlimited'>;
declare function isPrintSupply<K extends PrintSupply['__kind']>(kind: K, value: PrintSupply): value is PrintSupply & {
    __kind: K;
};

/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

type Metadata = {
    key: Key;
    updateAuthority: Address;
    mint: Address;
    data: Data;
    primarySaleHappened: boolean;
    isMutable: boolean;
    editionNonce: Option<number>;
    tokenStandard: Option<TokenStandard>;
    collection: Option<Collection>;
    uses: Option<Uses>;
    collectionDetails: Option<CollectionDetails>;
    programmableConfig: Option<ProgrammableConfig>;
};
type MetadataArgs = {
    key: KeyArgs;
    updateAuthority: Address;
    mint: Address;
    data: DataArgs;
    primarySaleHappened: boolean;
    isMutable: boolean;
    editionNonce: OptionOrNullable<number>;
    tokenStandard: OptionOrNullable<TokenStandardArgs>;
    collection: OptionOrNullable<CollectionArgs>;
    uses: OptionOrNullable<UsesArgs>;
    collectionDetails: OptionOrNullable<CollectionDetailsArgs>;
    programmableConfig: OptionOrNullable<ProgrammableConfigArgs>;
};
declare function getMetadataEncoder(): Encoder$1<MetadataArgs>;
declare function getMetadataDecoder(): Decoder$1<Metadata>;
declare function getMetadataCodec(): Codec$1<MetadataArgs, Metadata>;
declare function decodeMetadata<TAddress extends string = string>(encodedAccount: EncodedAccount<TAddress>): Account<Metadata, TAddress>;
declare function decodeMetadata<TAddress extends string = string>(encodedAccount: MaybeEncodedAccount<TAddress>): MaybeAccount<Metadata, TAddress>;
declare function fetchMetadata<TAddress extends string = string>(rpc: Parameters<typeof fetchEncodedAccount>[0], address: Address<TAddress>, config?: FetchAccountConfig): Promise<Account<Metadata, TAddress>>;
declare function fetchMaybeMetadata<TAddress extends string = string>(rpc: Parameters<typeof fetchEncodedAccount>[0], address: Address<TAddress>, config?: FetchAccountConfig): Promise<MaybeAccount<Metadata, TAddress>>;
declare function fetchAllMetadata(rpc: Parameters<typeof fetchEncodedAccounts>[0], addresses: Array<Address>, config?: FetchAccountsConfig): Promise<Account<Metadata>[]>;
declare function fetchAllMaybeMetadata(rpc: Parameters<typeof fetchEncodedAccounts>[0], addresses: Array<Address>, config?: FetchAccountsConfig): Promise<MaybeAccount<Metadata>[]>;

/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

declare const TOKEN_METADATA_PROGRAM_ADDRESS: Address<"metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s">;
declare enum TokenMetadataAccount {
    CollectionAuthorityRecord = 0,
    MetadataDelegateRecord = 1,
    HolderDelegateRecord = 2,
    Edition = 3,
    EditionMarker = 4,
    EditionMarkerV2 = 5,
    TokenOwnedEscrow = 6,
    MasterEditionV2 = 7,
    MasterEditionV1 = 8,
    Metadata = 9,
    TokenRecord = 10,
    ReservationListV2 = 11,
    ReservationListV1 = 12,
    UseAuthorityRecord = 13
}
declare enum TokenMetadataInstruction {
    CreateMetadataAccount = 0,
    UpdateMetadataAccount = 1,
    DeprecatedCreateMasterEdition = 2,
    DeprecatedMintNewEditionFromMasterEditionViaPrintingToken = 3,
    UpdatePrimarySaleHappenedViaToken = 4,
    DeprecatedSetReservationList = 5,
    DeprecatedCreateReservationList = 6,
    SignMetadata = 7,
    DeprecatedMintPrintingTokensViaToken = 8,
    DeprecatedMintPrintingTokens = 9,
    CreateMasterEdition = 10,
    MintNewEditionFromMasterEditionViaToken = 11,
    ConvertMasterEditionV1ToV2 = 12,
    MintNewEditionFromMasterEditionViaVaultProxy = 13,
    PuffMetadata = 14,
    UpdateMetadataAccountV2 = 15,
    CreateMetadataAccountV2 = 16,
    CreateMasterEditionV3 = 17,
    VerifyCollection = 18,
    Utilize = 19,
    ApproveUseAuthority = 20,
    RevokeUseAuthority = 21,
    UnverifyCollection = 22,
    ApproveCollectionAuthority = 23,
    RevokeCollectionAuthority = 24,
    SetAndVerifyCollection = 25,
    FreezeDelegatedAccount = 26,
    ThawDelegatedAccount = 27,
    RemoveCreatorVerification = 28,
    BurnNft = 29,
    VerifySizedCollectionItem = 30,
    UnverifySizedCollectionItem = 31,
    SetAndVerifySizedCollectionItem = 32,
    CreateMetadataAccountV3 = 33,
    SetCollectionSize = 34,
    SetTokenStandard = 35,
    BubblegumSetCollectionSize = 36,
    BurnEditionNft = 37,
    CreateEscrowAccount = 38,
    CloseEscrowAccount = 39,
    TransferOutOfEscrow = 40,
    Burn = 41,
    Create = 42,
    Mint = 43,
    Delegate = 44,
    Revoke = 45,
    Lock = 46,
    Unlock = 47,
    Migrate = 48,
    Transfer = 49,
    Update = 50,
    Use = 51,
    Verify = 52,
    Unverify = 53,
    Collect = 54,
    Print = 55,
    Resize = 56,
    CloseAccounts = 57
}

/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

declare const CREATE_METADATA_ACCOUNT_V3_DISCRIMINATOR = 33;
declare function getCreateMetadataAccountV3DiscriminatorBytes(): ReadonlyUint8Array$1;
type CreateMetadataAccountV3Instruction<TProgram extends string = typeof TOKEN_METADATA_PROGRAM_ADDRESS, TAccountMetadata extends string | IAccountMeta<string> = string, TAccountMint extends string | IAccountMeta<string> = string, TAccountMintAuthority extends string | IAccountMeta<string> = string, TAccountPayer extends string | IAccountMeta<string> = string, TAccountUpdateAuthority extends string | IAccountMeta<string> = string, TAccountSystemProgram extends string | IAccountMeta<string> = "11111111111111111111111111111111", TAccountRent extends string | IAccountMeta<string> | undefined = undefined, TRemainingAccounts extends readonly IAccountMeta<string>[] = []> = IInstruction<TProgram> & IInstructionWithData<Uint8Array> & IInstructionWithAccounts<[
    TAccountMetadata extends string ? WritableAccount<TAccountMetadata> : TAccountMetadata,
    TAccountMint extends string ? ReadonlyAccount<TAccountMint> : TAccountMint,
    TAccountMintAuthority extends string ? ReadonlySignerAccount<TAccountMintAuthority> & IAccountSignerMeta<TAccountMintAuthority> : TAccountMintAuthority,
    TAccountPayer extends string ? WritableSignerAccount<TAccountPayer> & IAccountSignerMeta<TAccountPayer> : TAccountPayer,
    TAccountUpdateAuthority extends string ? ReadonlyAccount<TAccountUpdateAuthority> : TAccountUpdateAuthority,
    TAccountSystemProgram extends string ? ReadonlyAccount<TAccountSystemProgram> : TAccountSystemProgram,
    ...(TAccountRent extends undefined ? [] : [TAccountRent extends string ? ReadonlyAccount<TAccountRent> : TAccountRent]),
    ...TRemainingAccounts
]>;
type CreateMetadataAccountV3InstructionData = {
    discriminator: number;
    data: DataV2;
    isMutable: boolean;
    collectionDetails: Option$1<CollectionDetails>;
};
type CreateMetadataAccountV3InstructionDataArgs = {
    data: DataV2Args;
    isMutable: boolean;
    collectionDetails: OptionOrNullable$1<CollectionDetailsArgs>;
};
declare function getCreateMetadataAccountV3InstructionDataEncoder(): Encoder<CreateMetadataAccountV3InstructionDataArgs>;
declare function getCreateMetadataAccountV3InstructionDataDecoder(): Decoder<CreateMetadataAccountV3InstructionData>;
declare function getCreateMetadataAccountV3InstructionDataCodec(): Codec<CreateMetadataAccountV3InstructionDataArgs, CreateMetadataAccountV3InstructionData>;
type CreateMetadataAccountV3Input<TAccountMetadata extends string = string, TAccountMint extends string = string, TAccountMintAuthority extends string = string, TAccountPayer extends string = string, TAccountUpdateAuthority extends string = string, TAccountSystemProgram extends string = string, TAccountRent extends string = string> = {
    /** Metadata key (pda of ['metadata', program id, mint id]) */
    metadata: Address<TAccountMetadata>;
    /** Mint of token asset */
    mint: Address<TAccountMint>;
    /** Mint authority */
    mintAuthority: TransactionSigner<TAccountMintAuthority>;
    /** payer */
    payer: TransactionSigner<TAccountPayer>;
    /** update authority info */
    updateAuthority: Address<TAccountUpdateAuthority> | TransactionSigner<TAccountUpdateAuthority>;
    /** System program */
    systemProgram?: Address<TAccountSystemProgram>;
    /** Rent info */
    rent?: Address<TAccountRent>;
    data: CreateMetadataAccountV3InstructionDataArgs["data"];
    isMutable: CreateMetadataAccountV3InstructionDataArgs["isMutable"];
    collectionDetails: CreateMetadataAccountV3InstructionDataArgs["collectionDetails"];
};
declare function getCreateMetadataAccountV3Instruction<TAccountMetadata extends string, TAccountMint extends string, TAccountMintAuthority extends string, TAccountPayer extends string, TAccountUpdateAuthority extends string, TAccountSystemProgram extends string, TAccountRent extends string, TProgramAddress extends Address = typeof TOKEN_METADATA_PROGRAM_ADDRESS>(input: CreateMetadataAccountV3Input<TAccountMetadata, TAccountMint, TAccountMintAuthority, TAccountPayer, TAccountUpdateAuthority, TAccountSystemProgram, TAccountRent>, config?: {
    programAddress?: TProgramAddress;
}): CreateMetadataAccountV3Instruction<TProgramAddress, TAccountMetadata, TAccountMint, TAccountMintAuthority, TAccountPayer, (typeof input)["updateAuthority"] extends TransactionSigner<TAccountUpdateAuthority> ? ReadonlySignerAccount<TAccountUpdateAuthority> & IAccountSignerMeta<TAccountUpdateAuthority> : TAccountUpdateAuthority, TAccountSystemProgram, TAccountRent>;
type ParsedCreateMetadataAccountV3Instruction<TProgram extends string = typeof TOKEN_METADATA_PROGRAM_ADDRESS, TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[]> = {
    programAddress: Address<TProgram>;
    accounts: {
        /** Metadata key (pda of ['metadata', program id, mint id]) */
        metadata: TAccountMetas[0];
        /** Mint of token asset */
        mint: TAccountMetas[1];
        /** Mint authority */
        mintAuthority: TAccountMetas[2];
        /** payer */
        payer: TAccountMetas[3];
        /** update authority info */
        updateAuthority: TAccountMetas[4];
        /** System program */
        systemProgram: TAccountMetas[5];
        /** Rent info */
        rent?: TAccountMetas[6] | undefined;
    };
    data: CreateMetadataAccountV3InstructionData;
};
declare function parseCreateMetadataAccountV3Instruction<TProgram extends string, TAccountMetas extends readonly IAccountMeta[]>(instruction: IInstruction<TProgram> & IInstructionWithAccounts<TAccountMetas> & IInstructionWithData<Uint8Array>): ParsedCreateMetadataAccountV3Instruction<TProgram, TAccountMetas>;

declare const UPDATE_METADATA_ACCOUNT_V2_DISCRIMINATOR = 15;
declare function getUpdateMetadataAccountV2DiscriminatorBytes(): _solana_kit.ReadonlyUint8Array;
type UpdateMetadataAccountV2Instruction<TProgram extends string = typeof TOKEN_METADATA_PROGRAM_ADDRESS, TAccountMetadata extends string | IAccountMeta<string> = string, TAccountUpdateAuthority extends string | IAccountMeta<string> = string, TRemainingAccounts extends readonly IAccountMeta<string>[] = []> = IInstruction<TProgram> & IInstructionWithData<Uint8Array> & IInstructionWithAccounts<[
    TAccountMetadata extends string ? WritableAccount<TAccountMetadata> : TAccountMetadata,
    TAccountUpdateAuthority extends string ? ReadonlySignerAccount<TAccountUpdateAuthority> & IAccountSignerMeta<TAccountUpdateAuthority> : TAccountUpdateAuthority,
    ...TRemainingAccounts
]>;
type UpdateMetadataAccountV2InstructionData = {
    discriminator: number;
    data: Option<DataV2>;
    updateAuthority: Option<Address>;
    primarySaleHappened: Option<boolean>;
    isMutable: Option<boolean>;
};
type UpdateMetadataAccountV2InstructionDataArgs = {
    data: OptionOrNullable<DataV2Args>;
    updateAuthority: OptionOrNullable<Address>;
    primarySaleHappened: OptionOrNullable<boolean>;
    isMutable: OptionOrNullable<boolean>;
};
declare function getUpdateMetadataAccountV2InstructionDataEncoder(): Encoder$1<UpdateMetadataAccountV2InstructionDataArgs>;
declare function getUpdateMetadataAccountV2InstructionDataDecoder(): Decoder$1<UpdateMetadataAccountV2InstructionData>;
declare function getUpdateMetadataAccountV2InstructionDataCodec(): Codec$1<UpdateMetadataAccountV2InstructionDataArgs, UpdateMetadataAccountV2InstructionData>;
type UpdateMetadataAccountV2Input<TAccountMetadata extends string = string, TAccountUpdateAuthority extends string = string> = {
    /** Metadata account */
    metadata: Address<TAccountMetadata>;
    /** Update authority key */
    updateAuthority: TransactionSigner<TAccountUpdateAuthority>;
    data: UpdateMetadataAccountV2InstructionDataArgs["data"];
    updateAuthorityArg: UpdateMetadataAccountV2InstructionDataArgs["updateAuthority"];
    primarySaleHappened: UpdateMetadataAccountV2InstructionDataArgs["primarySaleHappened"];
    isMutable: UpdateMetadataAccountV2InstructionDataArgs["isMutable"];
};
declare function getUpdateMetadataAccountV2Instruction<TAccountMetadata extends string, TAccountUpdateAuthority extends string, TProgramAddress extends Address = typeof TOKEN_METADATA_PROGRAM_ADDRESS>(input: UpdateMetadataAccountV2Input<TAccountMetadata, TAccountUpdateAuthority>, config?: {
    programAddress?: TProgramAddress;
}): UpdateMetadataAccountV2Instruction<TProgramAddress, TAccountMetadata, TAccountUpdateAuthority>;
type ParsedUpdateMetadataAccountV2Instruction<TProgram extends string = typeof TOKEN_METADATA_PROGRAM_ADDRESS, TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[]> = {
    programAddress: Address<TProgram>;
    accounts: {
        /** Metadata account */
        metadata: TAccountMetas[0];
        /** Update authority key */
        updateAuthority: TAccountMetas[1];
    };
    data: UpdateMetadataAccountV2InstructionData;
};
declare function parseUpdateMetadataAccountV2Instruction<TProgram extends string, TAccountMetas extends readonly IAccountMeta[]>(instruction: IInstruction<TProgram> & IInstructionWithAccounts<TAccountMetas> & IInstructionWithData<Uint8Array>): ParsedUpdateMetadataAccountV2Instruction<TProgram, TAccountMetas>;

/**
 * Derive the Token Metadata address from a token's mint address
 *
 * @param `mint` - `Address` or `KeyPairSigner` of the token mint
 */
declare function getTokenMetadataAddress(mint: Address | KeyPairSigner): Promise<Address>;

export { type AddMemoInput, type AddMemoInstruction, type AddMemoInstructionData, type AddMemoInstructionDataArgs, type AssetData, type AssetDataArgs, type AuthorizationData, type AuthorizationDataArgs, CREATE_METADATA_ACCOUNT_V3_DISCRIMINATOR, type Collection, type CollectionArgs, type CollectionDetails, type CollectionDetailsArgs, type CollectionDetailsToggle, type CollectionDetailsToggleArgs, type CollectionToggle, type CollectionToggleArgs, type CreateArgs, type CreateArgsArgs, type CreateMetadataAccountV3Input, type CreateMetadataAccountV3Instruction, type CreateMetadataAccountV3InstructionData, type CreateMetadataAccountV3InstructionDataArgs, type Creator, type CreatorArgs, type Data, type DataArgs, type DataV2, type DataV2Args, type DelegateArgs, type DelegateArgsArgs, type EscrowAuthority, type EscrowAuthorityArgs, Key, type KeyArgs, MEMO_PROGRAM_ADDRESS, MemoInstruction, type Metadata, type MetadataArgs, type MintArgs, type MintArgsArgs, type ParsedAddMemoInstruction, type ParsedCreateMetadataAccountV3Instruction, type ParsedMemoInstruction, type ParsedUpdateMetadataAccountV2Instruction, type Payload, type PayloadArgs, type PayloadType, type PayloadTypeArgs, type PrintSupply, type PrintSupplyArgs, type ProgrammableConfig, type ProgrammableConfigArgs, type ProofInfo, type ProofInfoArgs, type Reservation, type ReservationArgs, type RuleSetToggle, type RuleSetToggleArgs, type SeedsVec, type SeedsVecArgs, TOKEN_METADATA_PROGRAM_ADDRESS, TokenMetadataAccount, TokenMetadataInstruction, TokenStandard, type TokenStandardArgs, UPDATE_METADATA_ACCOUNT_V2_DISCRIMINATOR, type UpdateArgs, type UpdateArgsArgs, type UpdateMetadataAccountV2Input, type UpdateMetadataAccountV2Instruction, type UpdateMetadataAccountV2InstructionData, type UpdateMetadataAccountV2InstructionDataArgs, UseMethod, type UseMethodArgs, type Uses, type UsesArgs, type UsesToggle, type UsesToggleArgs, collectionDetails, collectionDetailsToggle, collectionToggle, createArgs, decodeMetadata, delegateArgs, escrowAuthority, fetchAllMaybeMetadata, fetchAllMetadata, fetchMaybeMetadata, fetchMetadata, getAddMemoInstruction, getAddMemoInstructionDataCodec, getAddMemoInstructionDataDecoder, getAddMemoInstructionDataEncoder, getAssetDataCodec, getAssetDataDecoder, getAssetDataEncoder, getAuthorizationDataCodec, getAuthorizationDataDecoder, getAuthorizationDataEncoder, getCollectionCodec, getCollectionDecoder, getCollectionDetailsCodec, getCollectionDetailsDecoder, getCollectionDetailsEncoder, getCollectionDetailsToggleCodec, getCollectionDetailsToggleDecoder, getCollectionDetailsToggleEncoder, getCollectionEncoder, getCollectionToggleCodec, getCollectionToggleDecoder, getCollectionToggleEncoder, getCreateArgsCodec, getCreateArgsDecoder, getCreateArgsEncoder, getCreateMetadataAccountV3DiscriminatorBytes, getCreateMetadataAccountV3Instruction, getCreateMetadataAccountV3InstructionDataCodec, getCreateMetadataAccountV3InstructionDataDecoder, getCreateMetadataAccountV3InstructionDataEncoder, getCreatorCodec, getCreatorDecoder, getCreatorEncoder, getDataCodec, getDataDecoder, getDataEncoder, getDataV2Codec, getDataV2Decoder, getDataV2Encoder, getDelegateArgsCodec, getDelegateArgsDecoder, getDelegateArgsEncoder, getEscrowAuthorityCodec, getEscrowAuthorityDecoder, getEscrowAuthorityEncoder, getKeyCodec, getKeyDecoder, getKeyEncoder, getMetadataCodec, getMetadataDecoder, getMetadataEncoder, getMintArgsCodec, getMintArgsDecoder, getMintArgsEncoder, getPayloadCodec, getPayloadDecoder, getPayloadEncoder, getPayloadTypeCodec, getPayloadTypeDecoder, getPayloadTypeEncoder, getPrintSupplyCodec, getPrintSupplyDecoder, getPrintSupplyEncoder, getProgrammableConfigCodec, getProgrammableConfigDecoder, getProgrammableConfigEncoder, getProofInfoCodec, getProofInfoDecoder, getProofInfoEncoder, getReservationCodec, getReservationDecoder, getReservationEncoder, getRuleSetToggleCodec, getRuleSetToggleDecoder, getRuleSetToggleEncoder, getSeedsVecCodec, getSeedsVecDecoder, getSeedsVecEncoder, getTokenMetadataAddress, getTokenStandardCodec, getTokenStandardDecoder, getTokenStandardEncoder, getUpdateArgsCodec, getUpdateArgsDecoder, getUpdateArgsEncoder, getUpdateMetadataAccountV2DiscriminatorBytes, getUpdateMetadataAccountV2Instruction, getUpdateMetadataAccountV2InstructionDataCodec, getUpdateMetadataAccountV2InstructionDataDecoder, getUpdateMetadataAccountV2InstructionDataEncoder, getUseMethodCodec, getUseMethodDecoder, getUseMethodEncoder, getUsesCodec, getUsesDecoder, getUsesEncoder, getUsesToggleCodec, getUsesToggleDecoder, getUsesToggleEncoder, hasSetComputeLimitInstruction, hasSetComputeUnitPriceInstruction, isCollectionDetails, isCollectionDetailsToggle, isCollectionToggle, isCreateArgs, isDelegateArgs, isEscrowAuthority, isMintArgs, isPayloadType, isPrintSupply, isProgrammableConfig, isRuleSetToggle, isSetComputeLimitInstruction, isSetComputeUnitPriceInstruction, isUpdateArgs, isUsesToggle, mintArgs, parseAddMemoInstruction, parseCreateMetadataAccountV3Instruction, parseUpdateMetadataAccountV2Instruction, payloadType, printSupply, programmableConfig, ruleSetToggle, updateArgs, usesToggle };
