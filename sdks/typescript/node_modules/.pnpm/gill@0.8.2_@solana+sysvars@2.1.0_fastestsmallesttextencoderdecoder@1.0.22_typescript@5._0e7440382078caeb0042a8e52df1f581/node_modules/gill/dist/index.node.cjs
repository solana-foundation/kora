'use strict';

var kit = require('@solana/kit');
var computeBudget = require('@solana-program/compute-budget');
var assertions = require('@solana/assertions');

// src/index.ts

// src/core/debug.ts
var GILL_LOG_LEVELS = {
  debug: 0,
  info: 1,
  warn: 2,
  error: 3
};
var getMinLogLevel = () => process.env.GILL_DEBUG_LEVEL || global.__GILL_DEBUG_LEVEL__ || typeof window !== "undefined" && window.__GILL_DEBUG_LEVEL__ || "info";
var isDebugEnabled = () => Boolean(
  process.env.GILL_DEBUG_LEVEL || global.__GILL_DEBUG_LEVEL__ || process.env.GILL_DEBUG === "true" || process.env.GILL_DEBUG === "1" || global.__GILL_DEBUG__ === true || typeof window !== "undefined" && window.__GILL_DEBUG__ === true
);
function debug(message, level = "info", prefix = "[GILL]") {
  if (!isDebugEnabled()) return;
  if (GILL_LOG_LEVELS[level] < GILL_LOG_LEVELS[getMinLogLevel()]) return;
  const formattedMessage = typeof message === "string" ? message : JSON.stringify(message, null, 2);
  switch (level) {
    case "debug":
      console.log(prefix, formattedMessage);
      break;
    case "info":
      console.info(prefix, formattedMessage);
      break;
    case "warn":
      console.warn(prefix, formattedMessage);
      break;
    case "error":
      console.error(prefix, formattedMessage);
      break;
  }
}

// src/core/const.ts
var LAMPORTS_PER_SOL = 1e9;
var GENESIS_HASH = {
  mainnet: "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdpKuc147dw2N9d",
  devnet: "EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG",
  testnet: "4uhcVJyU9pJkvQyS88uRDiswHXSCkY3zQawwpjk2NsNY"
};

// src/core/utils.ts
function getMonikerFromGenesisHash(hash) {
  switch (hash) {
    case GENESIS_HASH.mainnet:
      return "mainnet";
    case GENESIS_HASH.devnet:
      return "devnet";
    case GENESIS_HASH.testnet:
      return "testnet";
    default:
      return "unknown";
  }
}
function checkedAddress(input) {
  return typeof input == "string" ? input : input.address;
}
function lamportsToSol(lamports) {
  return new Intl.NumberFormat("en-US", { maximumFractionDigits: 9 }).format(`${lamports}E-9`);
}

// src/core/rpc.ts
function localnet(putativeString) {
  return putativeString;
}
function getPublicSolanaRpcUrl(cluster) {
  switch (cluster) {
    case "devnet":
      return "https://api.devnet.solana.com";
    case "testnet":
      return "https://api.testnet.solana.com";
    case "mainnet-beta":
    case "mainnet":
      return "https://api.mainnet-beta.solana.com";
    case "localnet":
    case "localhost":
      return "http://127.0.0.1:8899";
    default:
      throw new Error("Invalid cluster moniker");
  }
}

// src/core/explorer.ts
function getExplorerLink(props = {}) {
  let url = new URL("https://explorer.solana.com");
  if (!props.cluster || props.cluster == "mainnet") props.cluster = "mainnet-beta";
  if ("address" in props) {
    url.pathname = `/address/${props.address}`;
  } else if ("transaction" in props) {
    url.pathname = `/tx/${props.transaction}`;
  } else if ("block" in props) {
    url.pathname = `/block/${props.block}`;
  }
  if (props.cluster !== "mainnet-beta") {
    if (props.cluster === "localnet" || props.cluster === "localhost") {
      url.searchParams.set("cluster", "custom");
      url.searchParams.set("customUrl", "http://localhost:8899");
    } else {
      url.searchParams.set("cluster", props.cluster);
    }
  }
  return url.toString();
}
function createTransaction({
  version,
  feePayer,
  instructions,
  latestBlockhash,
  computeUnitLimit,
  computeUnitPrice
}) {
  return kit.pipe(
    kit.createTransactionMessage({ version }),
    (tx) => {
      if (latestBlockhash) {
        tx = kit.setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx);
      }
      if (typeof feePayer !== "string" && "address" in feePayer && kit.isTransactionSigner(feePayer)) {
        return kit.setTransactionMessageFeePayerSigner(feePayer, tx);
      } else return kit.setTransactionMessageFeePayer(feePayer, tx);
    },
    (tx) => {
      if (typeof computeUnitLimit !== "undefined") {
        tx = kit.appendTransactionMessageInstruction(
          computeBudget.getSetComputeUnitLimitInstruction({ units: Number(computeUnitLimit) }),
          tx
        );
      }
      if (typeof computeUnitPrice !== "undefined") {
        tx = kit.appendTransactionMessageInstruction(
          computeBudget.getSetComputeUnitPriceInstruction({ microLamports: Number(computeUnitPrice) }),
          tx
        );
      }
      return kit.appendTransactionMessageInstructions(instructions, tx);
    }
  );
}
function sendAndConfirmTransactionWithSignersFactory({
  rpc,
  rpcSubscriptions
}) {
  const sendAndConfirmTransaction = kit.sendAndConfirmTransactionFactory({ rpc, rpcSubscriptions });
  return async function sendAndConfirmTransactionWithSigners(transaction, config = { commitment: "confirmed" }) {
    if ("messageBytes" in transaction == false) {
      transaction = await kit.signTransactionMessageWithSigners(transaction);
    }
    debug(`Sending transaction: ${getExplorerLink({ transaction: kit.getSignatureFromTransaction(transaction) })}`);
    debug(`Transaction as base64: ${kit.getBase64EncodedWireTransaction(transaction)}`, "debug");
    await sendAndConfirmTransaction(transaction, config);
    return kit.getSignatureFromTransaction(transaction);
  };
}
function isSetComputeLimitInstruction(instruction) {
  return kit.isInstructionForProgram(instruction, computeBudget.COMPUTE_BUDGET_PROGRAM_ADDRESS) && kit.isInstructionWithData(instruction) && instruction.data[0] === computeBudget.ComputeBudgetInstruction.SetComputeUnitLimit;
}
function transactionToBase64(tx) {
  if ("messageBytes" in tx) return kit.pipe(tx, kit.getBase64EncodedWireTransaction);
  else return kit.pipe(tx, kit.compileTransaction, kit.getBase64EncodedWireTransaction);
}
async function transactionToBase64WithSigners(tx) {
  if ("messageBytes" in tx) return transactionToBase64(tx);
  else return transactionToBase64(await kit.partiallySignTransactionMessageWithSigners(tx));
}

// src/core/prepare-transaction.ts
async function prepareTransaction(config) {
  if (!config.computeUnitLimitMultiplier) config.computeUnitLimitMultiplier = 1.1;
  if (config.blockhashReset !== false) config.blockhashReset = true;
  const computeBudgetIndex = {
    limit: -1,
    price: -1
  };
  config.transaction.instructions.map((ix, index) => {
    if (ix.programAddress != computeBudget.COMPUTE_BUDGET_PROGRAM_ADDRESS) return;
    if (isSetComputeLimitInstruction(ix)) {
      computeBudgetIndex.limit = index;
    }
  });
  if (computeBudgetIndex.limit < 0 || config.computeUnitLimitReset) {
    const units = await kit.getComputeUnitEstimateForTransactionMessageFactory({ rpc: config.rpc })(config.transaction);
    debug(`Obtained compute units from simulation: ${units}`, "debug");
    const ix = computeBudget.getSetComputeUnitLimitInstruction({
      units: units * config.computeUnitLimitMultiplier
    });
    if (computeBudgetIndex.limit < 0) {
      config.transaction = kit.appendTransactionMessageInstruction(ix, config.transaction);
    } else if (config.computeUnitLimitReset) {
      const nextInstructions = [...config.transaction.instructions];
      nextInstructions.splice(computeBudgetIndex.limit, 1, ix);
      config.transaction = Object.freeze({
        ...config.transaction,
        instructions: nextInstructions
      });
    }
  }
  if (config.blockhashReset || "lifetimeConstraint" in config.transaction == false) {
    const { value: latestBlockhash } = await config.rpc.getLatestBlockhash().send();
    if ("lifetimeConstraint" in config.transaction == false) {
      debug("Transaction missing latest blockhash, fetching one.", "debug");
      config.transaction = kit.setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, config.transaction);
    } else if (config.blockhashReset) {
      debug("Auto resetting the latest blockhash.", "debug");
      config.transaction = Object.freeze({
        ...config.transaction,
        lifetimeConstraint: latestBlockhash
      });
    }
  }
  kit.assertIsTransactionMessageWithBlockhashLifetime(config.transaction);
  if (isDebugEnabled()) {
    debug(`Transaction as base64: ${await transactionToBase64WithSigners(config.transaction)}`, "debug");
  }
  return config.transaction;
}
function simulateTransactionFactory({ rpc }) {
  return async function simulateTransaction(transaction, config) {
    if ("messageBytes" in transaction == false) {
      transaction = await kit.partiallySignTransactionMessageWithSigners(transaction);
    }
    return rpc.simulateTransaction(kit.getBase64EncodedWireTransaction(transaction), {
      replaceRecentBlockhash: true,
      // innerInstructions: true,
      ...config,
      sigVerify: false,
      encoding: "base64"
    }).send();
  };
}

// src/core/create-solana-client.ts
function createSolanaClient({
  urlOrMoniker,
  rpcConfig,
  rpcSubscriptionsConfig
}) {
  if (!urlOrMoniker) throw new Error("Cluster url or moniker is required");
  if (urlOrMoniker instanceof URL == false) {
    try {
      urlOrMoniker = new URL(urlOrMoniker.toString());
    } catch (err) {
      try {
        urlOrMoniker = new URL(getPublicSolanaRpcUrl(urlOrMoniker.toString()));
      } catch (err2) {
        throw new Error("Invalid URL or cluster moniker");
      }
    }
  }
  if (!urlOrMoniker.protocol.match(/^https?/i)) {
    throw new Error("Unsupported protocol. Only HTTP and HTTPS are supported");
  }
  if (rpcConfig?.port) {
    urlOrMoniker.port = rpcConfig.port.toString();
  }
  const rpc = kit.createSolanaRpc(urlOrMoniker.toString(), rpcConfig);
  urlOrMoniker.protocol = urlOrMoniker.protocol.replace("http", "ws");
  if (rpcSubscriptionsConfig?.port) {
    urlOrMoniker.port = rpcSubscriptionsConfig.port.toString();
  } else if (urlOrMoniker.hostname == "localhost" || urlOrMoniker.hostname.startsWith("127")) {
    urlOrMoniker.port = "8900";
  }
  const rpcSubscriptions = kit.createSolanaRpcSubscriptions(
    urlOrMoniker.toString(),
    rpcSubscriptionsConfig
  );
  return {
    rpc,
    rpcSubscriptions,
    sendAndConfirmTransaction: sendAndConfirmTransactionWithSignersFactory({
      // @ts-ignore - TODO(FIXME:nick)
      rpc,
      // @ts-ignore - TODO(FIXME:nick)
      rpcSubscriptions
    }),
    // @ts-ignore
    simulateTransaction: simulateTransactionFactory({ rpc })
  };
}

// src/core/accounts.ts
function getMinimumBalanceForRentExemption(space = 0) {
  const RENT = {
    /**
     * Account storage overhead for calculation of base rent. (aka the number of bytes required to store an account with no data.
     */
    ACCOUNT_STORAGE_OVERHEAD: 128n,
    /**
     * Amount of time (in years) a balance must include rent for the account to
     * be rent exempt.
     */
    DEFAULT_EXEMPTION_THRESHOLD: BigInt(Math.floor(2 * 1e3)) / 1000n,
    /**
     * Default rental rate in lamports/byte-year. This calculation is based on:
     * - 10^9 lamports per SOL
     * - $1 per SOL
     * - $0.01 per megabyte day
     * - $3.65 per megabyte year
     */
    DEFAULT_LAMPORTS_PER_BYTE_YEAR: BigInt(
      Math.floor(1e9 / 100 * 365 / (1024 * 1024))
    )
  };
  return (RENT.ACCOUNT_STORAGE_OVERHEAD + BigInt(space)) * RENT.DEFAULT_LAMPORTS_PER_BYTE_YEAR * RENT.DEFAULT_EXEMPTION_THRESHOLD / 1n;
}
function assertKeyPairIsExtractable(keyPair) {
  assertions.assertKeyExporterIsAvailable();
  if (!keyPair.privateKey) {
    throw new Error("Keypair is missing private key");
  }
  if (!keyPair.publicKey) {
    throw new Error("Keypair is missing public key");
  }
  if (!keyPair.privateKey.extractable) {
    throw new Error("Private key is not extractable");
  }
}
async function generateExtractableKeyPair() {
  await assertions.assertKeyGenerationIsAvailable();
  return crypto.subtle.generateKey(
    /* algorithm */
    "Ed25519",
    // Native implementation status: https://github.com/WICG/webcrypto-secure-curves/issues/20
    /* extractable */
    true,
    /* allowed uses */
    ["sign", "verify"]
  );
}
async function generateExtractableKeyPairSigner() {
  return kit.createSignerFromKeyPair(await generateExtractableKeyPair());
}
async function extractBytesFromKeyPair(keypair) {
  assertKeyPairIsExtractable(keypair);
  const [publicKeyBytes, privateKeyJwk] = await Promise.all([
    crypto.subtle.exportKey("raw", keypair.publicKey),
    crypto.subtle.exportKey("jwk", keypair.privateKey)
  ]);
  if (!privateKeyJwk.d) throw new Error("Failed to get private key bytes");
  return new Uint8Array([...Buffer.from(privateKeyJwk.d, "base64"), ...new Uint8Array(publicKeyBytes)]);
}
async function extractBytesFromKeyPairSigner(keypairSigner) {
  return extractBytesFromKeyPair(keypairSigner.keyPair);
}
async function createKeypairFromBase58(punitiveSecretKey) {
  return kit.createKeyPairFromBytes(kit.getBase58Encoder().encode(punitiveSecretKey));
}
async function createKeypairSignerFromBase58(punitiveSecretKey) {
  return kit.createSignerFromKeyPair(await createKeypairFromBase58(punitiveSecretKey));
}
function transactionFromBase64(base64EncodedTransaction) {
  return kit.getTransactionDecoder().decode(kit.getBase64Encoder().encode(base64EncodedTransaction));
}

exports.GENESIS_HASH = GENESIS_HASH;
exports.LAMPORTS_PER_SOL = LAMPORTS_PER_SOL;
exports.assertKeyPairIsExtractable = assertKeyPairIsExtractable;
exports.checkedAddress = checkedAddress;
exports.createKeypairFromBase58 = createKeypairFromBase58;
exports.createKeypairSignerFromBase58 = createKeypairSignerFromBase58;
exports.createSolanaClient = createSolanaClient;
exports.createTransaction = createTransaction;
exports.debug = debug;
exports.extractBytesFromKeyPair = extractBytesFromKeyPair;
exports.extractBytesFromKeyPairSigner = extractBytesFromKeyPairSigner;
exports.generateExtractableKeyPair = generateExtractableKeyPair;
exports.generateExtractableKeyPairSigner = generateExtractableKeyPairSigner;
exports.getExplorerLink = getExplorerLink;
exports.getMinimumBalanceForRentExemption = getMinimumBalanceForRentExemption;
exports.getMonikerFromGenesisHash = getMonikerFromGenesisHash;
exports.getPublicSolanaRpcUrl = getPublicSolanaRpcUrl;
exports.isDebugEnabled = isDebugEnabled;
exports.lamportsToSol = lamportsToSol;
exports.localnet = localnet;
exports.prepareTransaction = prepareTransaction;
exports.sendAndConfirmTransactionWithSignersFactory = sendAndConfirmTransactionWithSignersFactory;
exports.simulateTransactionFactory = simulateTransactionFactory;
exports.transactionFromBase64 = transactionFromBase64;
exports.transactionToBase64 = transactionToBase64;
exports.transactionToBase64WithSigners = transactionToBase64WithSigners;
Object.keys(kit).forEach(function (k) {
  if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () { return kit[k]; }
  });
});
//# sourceMappingURL=index.node.cjs.map
//# sourceMappingURL=index.node.cjs.map