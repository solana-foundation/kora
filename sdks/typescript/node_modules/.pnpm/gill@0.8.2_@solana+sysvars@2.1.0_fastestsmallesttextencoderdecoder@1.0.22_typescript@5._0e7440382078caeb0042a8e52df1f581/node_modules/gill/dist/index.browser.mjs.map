{"version":3,"sources":["../src/core/debug.ts","../src/core/const.ts","../src/core/utils.ts","../src/core/rpc.ts","../src/core/explorer.ts","../src/core/create-transaction.ts","../src/core/send-and-confirm-transaction-with-signers.ts","../src/programs/compute-budget.ts","../src/core/base64-to-transaction.ts","../src/core/prepare-transaction.ts","../src/core/simulate-transaction.ts","../src/core/create-solana-client.ts","../src/core/accounts.ts","../src/core/keypairs-extractable.ts","../src/core/keypairs-base58.ts","../src/core/base64-from-transaction.ts"],"names":["pipe","getBase64EncodedWireTransaction","COMPUTE_BUDGET_PROGRAM_ADDRESS","getSetComputeUnitLimitInstruction","appendTransactionMessageInstruction","setTransactionMessageLifetimeUsingBlockhash","partiallySignTransactionMessageWithSigners","err","createSignerFromKeyPair"],"mappings":"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","file":"index.browser.mjs","sourcesContent":["/**\n *\n */\n\ntype LogLevel = \"debug\" | \"info\" | \"warn\" | \"error\";\n\nconst GILL_LOG_LEVELS: Record<LogLevel, number> = {\n  debug: 0,\n  info: 1,\n  warn: 2,\n  error: 3,\n};\n\ndeclare global {\n  /**\n   * Whether or not to enable debug mode. When enabled, default log level of `info`\n   */\n  var __GILL_DEBUG__: boolean | undefined;\n  /**\n   * Set the a desired level of logs to be output in the application\n   *\n   * - Default: `info`\n   * - Options: `debug` | `info` | `warn` | `error`\n   */\n  var __GILL_DEBUG_LEVEL__: LogLevel | undefined;\n}\n\nconst getMinLogLevel = (): LogLevel =>\n  (process.env.GILL_DEBUG_LEVEL as LogLevel) ||\n  global.__GILL_DEBUG_LEVEL__ ||\n  (typeof window !== \"undefined\" && (window as any).__GILL_DEBUG_LEVEL__) ||\n  \"info\";\n\n/**\n * Check if the `gill` debug logger is enabled or not\n */\nexport const isDebugEnabled = (): boolean =>\n  Boolean(\n    process.env.GILL_DEBUG_LEVEL ||\n      global.__GILL_DEBUG_LEVEL__ ||\n      process.env.GILL_DEBUG === \"true\" ||\n      process.env.GILL_DEBUG === \"1\" ||\n      global.__GILL_DEBUG__ === true ||\n      (typeof window !== \"undefined\" && (window as any).__GILL_DEBUG__ === true),\n  );\n\n/**\n * Log debug messages based on the desired application's logging level.\n *\n * @param message - the message contents to be logged\n * @param level - default: `info` (see: {@link GILL_LOG_LEVELS})\n * @param prefix - default: `[GILL]`\n *\n * To enable gill's debug logger, set any of the following to `true`:\n * - `process.env.GILL_DEBUG`\n * - `global.__GILL_DEBUG__`\n * - `window.__GILL_DEBUG__`\n *\n * To set a desired level of logs to be output in the application, set the value of one of the following:\n * - `process.env.GILL_DEBUG_LEVEL`\n * - `global.__GILL_DEBUG_LEVEL__`\n * - `window.__GILL_DEBUG_LEVEL__`\n */\nexport function debug(message: unknown, level: LogLevel = \"info\", prefix: string = \"[GILL]\") {\n  if (!isDebugEnabled()) return;\n\n  if (GILL_LOG_LEVELS[level] < GILL_LOG_LEVELS[getMinLogLevel()]) return;\n\n  const formattedMessage = typeof message === \"string\" ? message : JSON.stringify(message, null, 2);\n\n  switch (level) {\n    case \"debug\":\n      console.log(prefix, formattedMessage);\n      break;\n    case \"info\":\n      console.info(prefix, formattedMessage);\n      break;\n    case \"warn\":\n      console.warn(prefix, formattedMessage);\n      break;\n    case \"error\":\n      console.error(prefix, formattedMessage);\n      break;\n  }\n}\n","/** 1 billion lamports per SOL */\nexport const LAMPORTS_PER_SOL = 1_000_000_000;\n\n/**\n * Genesis hash for Solana network clusters\n */\nexport const GENESIS_HASH = {\n  mainnet: \"5eykt4UsFv8P8NJdTREpY1vzqKqZKvdpKuc147dw2N9d\",\n  devnet: \"EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG\",\n  testnet: \"4uhcVJyU9pJkvQyS88uRDiswHXSCkY3zQawwpjk2NsNY\",\n};\n","import type { Address, KeyPairSigner } from \"@solana/kit\";\n\nimport type { SolanaClusterMoniker } from \"../types\";\nimport { GENESIS_HASH } from \"./const\";\n\n/**\n * Determine the Solana moniker from its genesis hash\n *\n * If the hash is NOT known, returns `unknown`\n */\nexport function getMonikerFromGenesisHash(hash: string): SolanaClusterMoniker | \"unknown\" {\n  switch (hash) {\n    case GENESIS_HASH.mainnet:\n      return \"mainnet\";\n    case GENESIS_HASH.devnet:\n      return \"devnet\";\n    case GENESIS_HASH.testnet:\n      return \"testnet\";\n    default:\n      return \"unknown\";\n  }\n}\n\nexport function checkedAddress(input: Address | KeyPairSigner): Address {\n  return typeof input == \"string\" ? input : input.address;\n}\n\n/**\n * Convert a lamport number to the human readable string of a SOL value\n */\nexport function lamportsToSol(lamports: bigint | number): string {\n  // @ts-expect-error This format is valid\n  return new Intl.NumberFormat(\"en-US\", { maximumFractionDigits: 9 }).format(`${lamports}E-9`);\n}\n","import type { DevnetUrl, MainnetUrl, TestnetUrl } from \"@solana/kit\";\nimport type { LocalnetUrl, ModifiedClusterUrl, SolanaClusterMoniker } from \"../types/rpc\";\n\nexport function localnet(putativeString: string): LocalnetUrl {\n  return putativeString as LocalnetUrl;\n}\n\n/**\n * Get a public Solana RPC endpoint for a cluster based on its moniker\n *\n * Note: These RPC URLs are rate limited and not suitable for production applications.\n */\nexport function getPublicSolanaRpcUrl(\n  cluster: SolanaClusterMoniker | \"mainnet-beta\" | \"localhost\",\n): ModifiedClusterUrl {\n  switch (cluster) {\n    case \"devnet\":\n      return \"https://api.devnet.solana.com\" as DevnetUrl;\n    case \"testnet\":\n      return \"https://api.testnet.solana.com\" as TestnetUrl;\n    case \"mainnet-beta\":\n    case \"mainnet\":\n      return \"https://api.mainnet-beta.solana.com\" as MainnetUrl;\n    case \"localnet\":\n    case \"localhost\":\n      return \"http://127.0.0.1:8899\" as LocalnetUrl;\n    default:\n      throw new Error(\"Invalid cluster moniker\");\n  }\n}\n","import type { GetExplorerLinkArgs } from \"../types\";\n\n/**\n * Craft a Solana Explorer link on any cluster\n */\nexport function getExplorerLink(props: GetExplorerLinkArgs = {}): string {\n  let url = new URL(\"https://explorer.solana.com\");\n\n  // default to mainnet / mainnet-beta\n  if (!props.cluster || props.cluster == \"mainnet\") props.cluster = \"mainnet-beta\";\n\n  if (\"address\" in props) {\n    url.pathname = `/address/${props.address}`;\n  } else if (\"transaction\" in props) {\n    url.pathname = `/tx/${props.transaction}`;\n  } else if (\"block\" in props) {\n    url.pathname = `/block/${props.block}`;\n  }\n\n  if (props.cluster !== \"mainnet-beta\") {\n    if (props.cluster === \"localnet\" || props.cluster === \"localhost\") {\n      // localnet technically isn't a cluster, so requires special handling\n      url.searchParams.set(\"cluster\", \"custom\");\n      url.searchParams.set(\"customUrl\", \"http://localhost:8899\");\n    } else {\n      url.searchParams.set(\"cluster\", props.cluster);\n    }\n  }\n\n  return url.toString();\n}\n","import type { Simplify } from \"../types\";\n\nimport { getSetComputeUnitLimitInstruction, getSetComputeUnitPriceInstruction } from \"@solana-program/compute-budget\";\nimport type {\n  Address,\n  ITransactionMessageWithFeePayer,\n  ITransactionMessageWithFeePayerSigner,\n  TransactionMessageWithBlockhashLifetime,\n  TransactionSigner,\n  TransactionVersion,\n} from \"@solana/kit\";\nimport {\n  appendTransactionMessageInstruction,\n  appendTransactionMessageInstructions,\n  createTransactionMessage,\n  isTransactionSigner,\n  pipe,\n  setTransactionMessageFeePayer,\n  setTransactionMessageFeePayerSigner,\n  setTransactionMessageLifetimeUsingBlockhash,\n} from \"@solana/kit\";\n\nimport type { CreateTransactionInput, FullTransaction } from \"../types/transactions\";\n\n/**\n * Simple interface for creating a Solana transaction\n */\nexport function createTransaction<TVersion extends TransactionVersion, TFeePayer extends TransactionSigner>(\n  props: CreateTransactionInput<TVersion, TFeePayer>,\n): FullTransaction<TVersion, ITransactionMessageWithFeePayerSigner>;\nexport function createTransaction<TVersion extends TransactionVersion, TFeePayer extends Address>(\n  props: CreateTransactionInput<TVersion, TFeePayer>,\n): FullTransaction<TVersion, ITransactionMessageWithFeePayer>;\nexport function createTransaction<\n  TVersion extends TransactionVersion,\n  TFeePayer extends Address,\n  TLifetimeConstraint extends TransactionMessageWithBlockhashLifetime[\"lifetimeConstraint\"],\n>(\n  props: CreateTransactionInput<TVersion, TFeePayer, TLifetimeConstraint>,\n): Simplify<FullTransaction<TVersion, ITransactionMessageWithFeePayer, TransactionMessageWithBlockhashLifetime>>;\nexport function createTransaction<\n  TVersion extends TransactionVersion,\n  TFeePayer extends TransactionSigner,\n  TLifetimeConstraint extends TransactionMessageWithBlockhashLifetime[\"lifetimeConstraint\"],\n>(\n  props: CreateTransactionInput<TVersion, TFeePayer, TLifetimeConstraint>,\n): Simplify<FullTransaction<TVersion, ITransactionMessageWithFeePayerSigner, TransactionMessageWithBlockhashLifetime>>;\nexport function createTransaction<TVersion extends TransactionVersion, TFeePayer extends Address | TransactionSigner>({\n  version,\n  feePayer,\n  instructions,\n  latestBlockhash,\n  computeUnitLimit,\n  computeUnitPrice,\n}: CreateTransactionInput<TVersion, TFeePayer>): FullTransaction<\n  TVersion,\n  ITransactionMessageWithFeePayer | ITransactionMessageWithFeePayerSigner\n> {\n  return pipe(\n    createTransactionMessage({ version }),\n    (tx) => {\n      if (latestBlockhash) {\n        tx = setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx);\n      }\n      if (typeof feePayer !== \"string\" && \"address\" in feePayer && isTransactionSigner(feePayer)) {\n        return setTransactionMessageFeePayerSigner(feePayer, tx);\n      } else return setTransactionMessageFeePayer(feePayer, tx);\n    },\n    (tx) => {\n      if (typeof computeUnitLimit !== \"undefined\") {\n        tx = appendTransactionMessageInstruction(\n          getSetComputeUnitLimitInstruction({ units: Number(computeUnitLimit) }),\n          tx,\n        );\n      }\n\n      if (typeof computeUnitPrice !== \"undefined\") {\n        tx = appendTransactionMessageInstruction(\n          getSetComputeUnitPriceInstruction({ microLamports: Number(computeUnitPrice) }),\n          tx,\n        );\n      }\n\n      return appendTransactionMessageInstructions(instructions, tx);\n    },\n  );\n}\n","import type {\n  CompilableTransactionMessage,\n  FullySignedTransaction,\n  GetEpochInfoApi,\n  GetSignatureStatusesApi,\n  Rpc,\n  RpcSubscriptions,\n  SendTransactionApi,\n  Signature,\n  SignatureNotificationsApi,\n  SlotNotificationsApi,\n  TransactionWithBlockhashLifetime,\n} from \"@solana/kit\";\nimport {\n  Commitment,\n  getBase64EncodedWireTransaction,\n  getSignatureFromTransaction,\n  sendAndConfirmTransactionFactory,\n  signTransactionMessageWithSigners,\n} from \"@solana/kit\";\nimport { type waitForRecentTransactionConfirmation } from \"@solana/transaction-confirmation\";\nimport { debug } from \"./debug\";\nimport { getExplorerLink } from \"./explorer\";\n\ninterface SendAndConfirmTransactionWithBlockhashLifetimeConfig\n  extends SendTransactionBaseConfig,\n    SendTransactionConfigWithoutEncoding {\n  confirmRecentTransaction: (\n    config: Omit<\n      Parameters<typeof waitForRecentTransactionConfirmation>[0],\n      \"getBlockHeightExceedencePromise\" | \"getRecentSignatureConfirmationPromise\"\n    >,\n  ) => Promise<void>;\n  transaction: FullySignedTransaction & TransactionWithBlockhashLifetime;\n}\n\ninterface SendTransactionBaseConfig extends SendTransactionConfigWithoutEncoding {\n  abortSignal?: AbortSignal;\n  commitment: Commitment;\n  rpc: Rpc<SendTransactionApi>;\n  transaction: FullySignedTransaction;\n}\n\ntype SendTransactionConfigWithoutEncoding = Omit<\n  NonNullable<Parameters<SendTransactionApi[\"sendTransaction\"]>[1]>,\n  \"encoding\"\n>;\n\nexport type SendAndConfirmTransactionWithSignersFunction = (\n  transaction: (FullySignedTransaction & TransactionWithBlockhashLifetime) | CompilableTransactionMessage,\n  config?: Omit<\n    SendAndConfirmTransactionWithBlockhashLifetimeConfig,\n    \"confirmRecentTransaction\" | \"rpc\" | \"transaction\"\n  >,\n) => Promise<Signature>;\n\ntype SendAndConfirmTransactionWithSignersFactoryConfig<TCluster> = {\n  rpc: Rpc<GetEpochInfoApi & GetSignatureStatusesApi & SendTransactionApi> & {\n    \"~cluster\"?: TCluster;\n  };\n  rpcSubscriptions: RpcSubscriptions<SignatureNotificationsApi & SlotNotificationsApi> & {\n    \"~cluster\"?: TCluster;\n  };\n};\n\nexport function sendAndConfirmTransactionWithSignersFactory({\n  rpc,\n  rpcSubscriptions,\n}: SendAndConfirmTransactionWithSignersFactoryConfig<\"devnet\">): SendAndConfirmTransactionWithSignersFunction;\nexport function sendAndConfirmTransactionWithSignersFactory({\n  rpc,\n  rpcSubscriptions,\n}: SendAndConfirmTransactionWithSignersFactoryConfig<\"testnet\">): SendAndConfirmTransactionWithSignersFunction;\nexport function sendAndConfirmTransactionWithSignersFactory({\n  rpc,\n  rpcSubscriptions,\n}: SendAndConfirmTransactionWithSignersFactoryConfig<\"mainnet\">): SendAndConfirmTransactionWithSignersFunction;\nexport function sendAndConfirmTransactionWithSignersFactory({\n  rpc,\n  rpcSubscriptions,\n}: SendAndConfirmTransactionWithSignersFactoryConfig<\"localnet\">): SendAndConfirmTransactionWithSignersFunction;\nexport function sendAndConfirmTransactionWithSignersFactory<\n  TCluster extends \"devnet\" | \"mainnet\" | \"testnet\" | \"localnet\" | undefined = undefined,\n>({\n  rpc,\n  rpcSubscriptions,\n}: SendAndConfirmTransactionWithSignersFactoryConfig<TCluster>): SendAndConfirmTransactionWithSignersFunction {\n  // @ts-ignore - TODO(FIXME)\n  const sendAndConfirmTransaction = sendAndConfirmTransactionFactory({ rpc, rpcSubscriptions });\n  return async function sendAndConfirmTransactionWithSigners(transaction, config = { commitment: \"confirmed\" }) {\n    if (\"messageBytes\" in transaction == false) {\n      transaction = (await signTransactionMessageWithSigners(transaction)) as Readonly<\n        FullySignedTransaction & TransactionWithBlockhashLifetime\n      >;\n    }\n    debug(`Sending transaction: ${getExplorerLink({ transaction: getSignatureFromTransaction(transaction) })}`);\n    debug(`Transaction as base64: ${getBase64EncodedWireTransaction(transaction)}`, \"debug\");\n    await sendAndConfirmTransaction(transaction, config);\n    return getSignatureFromTransaction(transaction);\n  };\n}\n","import { COMPUTE_BUDGET_PROGRAM_ADDRESS, ComputeBudgetInstruction } from \"@solana-program/compute-budget\";\nimport type { IInstruction, IInstructionWithData, TransactionMessage } from \"@solana/kit\";\nimport { isInstructionForProgram, isInstructionWithData } from \"@solana/kit\";\n\n/**\n * Check if a given instruction is a `SetComputeUnitLimit` instruction\n */\nexport function isSetComputeLimitInstruction(\n  instruction: IInstruction,\n): instruction is IInstruction<typeof COMPUTE_BUDGET_PROGRAM_ADDRESS> & IInstructionWithData<Uint8Array> {\n  return (\n    isInstructionForProgram(instruction, COMPUTE_BUDGET_PROGRAM_ADDRESS) &&\n    isInstructionWithData(instruction) &&\n    instruction.data[0] === ComputeBudgetInstruction.SetComputeUnitLimit\n  );\n}\n\n/**\n * Check if a given transaction contains a `SetComputeUnitLimit` instruction\n */\nexport function hasSetComputeLimitInstruction(tx: TransactionMessage): boolean {\n  return tx.instructions.filter(isSetComputeLimitInstruction).length == 1;\n}\n\n/**\n * Check if a given instruction is a `SetComputeUnitPrice` instruction\n */\nexport function isSetComputeUnitPriceInstruction(\n  instruction: IInstruction,\n): instruction is IInstruction<typeof COMPUTE_BUDGET_PROGRAM_ADDRESS> & IInstructionWithData<Uint8Array> {\n  return (\n    isInstructionForProgram(instruction, COMPUTE_BUDGET_PROGRAM_ADDRESS) &&\n    isInstructionWithData(instruction) &&\n    instruction.data[0] === ComputeBudgetInstruction.SetComputeUnitPrice\n  );\n}\n\n/**\n * Check if a given transaction contains a `SetComputeUnitPrice` instruction\n */\nexport function hasSetComputeUnitPriceInstruction(tx: TransactionMessage): boolean {\n  return tx.instructions.filter(isSetComputeUnitPriceInstruction).length == 1;\n}\n","import type { Base64EncodedWireTransaction, CompilableTransactionMessage, Transaction } from \"@solana/kit\";\nimport {\n  compileTransaction,\n  getBase64EncodedWireTransaction,\n  partiallySignTransactionMessageWithSigners,\n  pipe,\n} from \"@solana/kit\";\n\n/**\n * Compile a transaction to a base64 string\n *\n * Note: This will NOT attempt to sign the transaction,\n * so it will be missing `signatures` from any of the attached Signers\n *\n * Use {@link transactionToBase64WithSignatures} sign and base64 encode\n */\nexport function transactionToBase64(tx: CompilableTransactionMessage | Transaction): Base64EncodedWireTransaction {\n  if (\"messageBytes\" in tx) return pipe(tx, getBase64EncodedWireTransaction);\n  else return pipe(tx, compileTransaction, getBase64EncodedWireTransaction);\n}\n\n/**\n * Compile a transaction to a base64 string and sign it with all attached Signers\n *\n * See also {@link partiallySignTransactionMessageWithSigners}\n */\nexport async function transactionToBase64WithSigners(\n  tx: CompilableTransactionMessage | Transaction,\n): Promise<Base64EncodedWireTransaction> {\n  if (\"messageBytes\" in tx) return transactionToBase64(tx);\n  else return transactionToBase64(await partiallySignTransactionMessageWithSigners(tx));\n}\n","import { COMPUTE_BUDGET_PROGRAM_ADDRESS, getSetComputeUnitLimitInstruction } from \"@solana-program/compute-budget\";\nimport type {\n  CompilableTransactionMessage,\n  GetLatestBlockhashApi,\n  ITransactionMessageWithFeePayer,\n  Rpc,\n  SimulateTransactionApi,\n  TransactionMessage,\n  TransactionMessageWithBlockhashLifetime,\n} from \"@solana/kit\";\nimport {\n  appendTransactionMessageInstruction,\n  assertIsTransactionMessageWithBlockhashLifetime,\n  getComputeUnitEstimateForTransactionMessageFactory,\n  setTransactionMessageLifetimeUsingBlockhash,\n} from \"@solana/kit\";\nimport { isSetComputeLimitInstruction } from \"../programs/compute-budget\";\nimport { transactionToBase64WithSigners } from \"./base64-to-transaction\";\nimport { debug, isDebugEnabled } from \"./debug\";\n\ntype PrepareCompilableTransactionMessage =\n  | CompilableTransactionMessage\n  | (ITransactionMessageWithFeePayer & TransactionMessage);\n\nexport type PrepareTransactionConfig<TMessage extends PrepareCompilableTransactionMessage> = {\n  /**\n   * Transaction to prepare for sending to the blockchain\n   */\n  transaction: TMessage;\n  /**\n   * RPC client capable of simulating transactions and getting the latest blockhash\n   **/\n  rpc: Rpc<SimulateTransactionApi & GetLatestBlockhashApi>;\n  /**\n   * Multiplier applied to the simulated compute unit value obtained from simulation\n   *\n   * Default: `1.1`\n   **/\n  computeUnitLimitMultiplier?: number;\n  /**\n   * Whether or not you wish to force reset the compute unit limit value (if one is already set)\n   * using the simulation response and `computeUnitLimitMultiplier`\n   **/\n  computeUnitLimitReset?: boolean;\n  /**\n   * Whether or not you wish to force reset the latest blockhash (if one is already set)\n   *\n   * Default: `true`\n   **/\n  blockhashReset?: boolean;\n};\n\n/**\n * Prepare a Transaction to be signed and sent to the network. Including:\n * - setting a compute unit limit (if not already set)\n * - fetching the latest blockhash (if not already set)\n * - (optional) simulating and resetting the compute unit limit\n * - (optional) resetting latest blockhash to the most recent\n */\nexport async function prepareTransaction<TMessage extends PrepareCompilableTransactionMessage>(\n  config: PrepareTransactionConfig<TMessage>,\n) {\n  // set the config defaults\n  if (!config.computeUnitLimitMultiplier) config.computeUnitLimitMultiplier = 1.1;\n  if (config.blockhashReset !== false) config.blockhashReset = true;\n\n  const computeBudgetIndex = {\n    limit: -1,\n    price: -1,\n  };\n\n  config.transaction.instructions.map((ix, index) => {\n    if (ix.programAddress != COMPUTE_BUDGET_PROGRAM_ADDRESS) return;\n\n    if (isSetComputeLimitInstruction(ix)) {\n      computeBudgetIndex.limit = index;\n    }\n    // else if (isSetComputeUnitPriceInstruction(ix)) {\n    //   computeBudgetIndex.price = index;\n    // }\n  });\n\n  // set a compute unit limit instruction\n  if (computeBudgetIndex.limit < 0 || config.computeUnitLimitReset) {\n    const units = await getComputeUnitEstimateForTransactionMessageFactory({ rpc: config.rpc })(config.transaction);\n    debug(`Obtained compute units from simulation: ${units}`, \"debug\");\n    const ix = getSetComputeUnitLimitInstruction({\n      units: units * config.computeUnitLimitMultiplier,\n    });\n\n    if (computeBudgetIndex.limit < 0) {\n      config.transaction = appendTransactionMessageInstruction(ix, config.transaction);\n    } else if (config.computeUnitLimitReset) {\n      const nextInstructions = [...config.transaction.instructions];\n      nextInstructions.splice(computeBudgetIndex.limit, 1, ix);\n      config.transaction = Object.freeze({\n        ...config.transaction,\n        instructions: nextInstructions,\n      } as typeof config.transaction);\n    }\n  }\n\n  // update the latest blockhash\n  if (config.blockhashReset || \"lifetimeConstraint\" in config.transaction == false) {\n    const { value: latestBlockhash } = await config.rpc.getLatestBlockhash().send();\n    if (\"lifetimeConstraint\" in config.transaction == false) {\n      debug(\"Transaction missing latest blockhash, fetching one.\", \"debug\");\n      config.transaction = setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, config.transaction);\n    } else if (config.blockhashReset) {\n      debug(\"Auto resetting the latest blockhash.\", \"debug\");\n      config.transaction = Object.freeze({\n        ...config.transaction,\n        lifetimeConstraint: latestBlockhash,\n      } as typeof config.transaction & TransactionMessageWithBlockhashLifetime);\n    }\n  }\n\n  assertIsTransactionMessageWithBlockhashLifetime(config.transaction);\n\n  // skip the async call if debugging is off\n  if (isDebugEnabled()) {\n    debug(`Transaction as base64: ${await transactionToBase64WithSigners(config.transaction)}`, \"debug\");\n  }\n\n  return config.transaction;\n}\n","import type { CompilableTransactionMessage, Rpc, SimulateTransactionApi, Transaction } from \"@solana/kit\";\nimport { getBase64EncodedWireTransaction, partiallySignTransactionMessageWithSigners } from \"@solana/kit\";\nimport type { Simplify } from \"./../types/index\";\n\nexport type SimulateTransactionFunction = (\n  transaction: Transaction | CompilableTransactionMessage,\n  config?: Simplify<Omit<Parameters<SimulateTransactionApi[\"simulateTransaction\"]>[1], \"encoding\" | \"sigVerify\">>,\n) => Promise<ReturnType<SimulateTransactionApi[\"simulateTransaction\"]>>;\n\ntype SimulateTransactionFactoryConfig<TCluster> = {\n  rpc: Rpc<SimulateTransactionApi> & {\n    \"~cluster\"?: TCluster;\n  };\n};\n\nexport function simulateTransactionFactory({\n  rpc,\n}: SimulateTransactionFactoryConfig<\"devnet\">): SimulateTransactionFunction;\nexport function simulateTransactionFactory({\n  rpc,\n}: SimulateTransactionFactoryConfig<\"testnet\">): SimulateTransactionFunction;\nexport function simulateTransactionFactory({\n  rpc,\n}: SimulateTransactionFactoryConfig<\"mainnet\">): SimulateTransactionFunction;\nexport function simulateTransactionFactory({\n  rpc,\n}: SimulateTransactionFactoryConfig<\"localnet\">): SimulateTransactionFunction;\nexport function simulateTransactionFactory<\n  TCluster extends \"devnet\" | \"mainnet\" | \"testnet\" | \"localnet\" | void = void,\n>({ rpc }: SimulateTransactionFactoryConfig<TCluster>): SimulateTransactionFunction {\n  return async function simulateTransaction(transaction, config) {\n    if (\"messageBytes\" in transaction == false) {\n      transaction = await partiallySignTransactionMessageWithSigners(transaction);\n    }\n\n    return rpc\n      .simulateTransaction(getBase64EncodedWireTransaction(transaction), {\n        replaceRecentBlockhash: true,\n        // innerInstructions: true,\n        ...config,\n        sigVerify: false,\n        encoding: \"base64\",\n      })\n      .send();\n  };\n}\n","import type { DevnetUrl, MainnetUrl, TestnetUrl } from \"@solana/kit\";\nimport { createSolanaRpc, createSolanaRpcSubscriptions } from \"@solana/kit\";\n\nimport type { CreateSolanaClientArgs, LocalnetUrl, ModifiedClusterUrl, SolanaClient } from \"../types/rpc\";\nimport { getPublicSolanaRpcUrl } from \"./rpc\";\nimport { sendAndConfirmTransactionWithSignersFactory } from \"./send-and-confirm-transaction-with-signers\";\nimport { simulateTransactionFactory } from \"./simulate-transaction\";\n\n/**\n * Create a Solana `rpc` and `rpcSubscriptions` client\n */\nexport function createSolanaClient(\n  props: Omit<CreateSolanaClientArgs<MainnetUrl | \"mainnet\">, \"urlOrMoniker\"> & {\n    urlOrMoniker: \"mainnet\";\n  },\n): SolanaClient<MainnetUrl>;\nexport function createSolanaClient(\n  props: Omit<CreateSolanaClientArgs<DevnetUrl | \"devnet\">, \"urlOrMoniker\"> & {\n    urlOrMoniker: \"devnet\";\n  },\n): SolanaClient<DevnetUrl>;\nexport function createSolanaClient(\n  props: Omit<CreateSolanaClientArgs<TestnetUrl | \"testnet\">, \"urlOrMoniker\"> & {\n    urlOrMoniker: \"testnet\";\n  },\n): SolanaClient<TestnetUrl>;\nexport function createSolanaClient(\n  props: Omit<CreateSolanaClientArgs<LocalnetUrl | \"localnet\">, \"urlOrMoniker\"> & {\n    urlOrMoniker: \"localnet\";\n  },\n): SolanaClient<LocalnetUrl>;\nexport function createSolanaClient<TClusterUrl extends ModifiedClusterUrl>(\n  props: CreateSolanaClientArgs<TClusterUrl>,\n): SolanaClient<TClusterUrl>;\nexport function createSolanaClient<TCluster extends ModifiedClusterUrl>({\n  urlOrMoniker,\n  rpcConfig,\n  rpcSubscriptionsConfig,\n}: CreateSolanaClientArgs<TCluster>) {\n  if (!urlOrMoniker) throw new Error(\"Cluster url or moniker is required\");\n  if (urlOrMoniker instanceof URL == false) {\n    try {\n      urlOrMoniker = new URL(urlOrMoniker.toString());\n    } catch (err) {\n      try {\n        urlOrMoniker = new URL(getPublicSolanaRpcUrl(urlOrMoniker.toString() as any));\n      } catch (err) {\n        throw new Error(\"Invalid URL or cluster moniker\");\n      }\n    }\n  }\n\n  if (!urlOrMoniker.protocol.match(/^https?/i)) {\n    throw new Error(\"Unsupported protocol. Only HTTP and HTTPS are supported\");\n  }\n\n  if (rpcConfig?.port) {\n    urlOrMoniker.port = rpcConfig.port.toString();\n  }\n\n  const rpc = createSolanaRpc<TCluster>(urlOrMoniker.toString() as TCluster, rpcConfig);\n\n  urlOrMoniker.protocol = urlOrMoniker.protocol.replace('http', 'ws');\n\n  if (rpcSubscriptionsConfig?.port) {\n    urlOrMoniker.port = rpcSubscriptionsConfig.port.toString();\n  } else if (urlOrMoniker.hostname == \"localhost\" || urlOrMoniker.hostname.startsWith(\"127\")) {\n    urlOrMoniker.port = \"8900\";\n  }\n\n  const rpcSubscriptions = createSolanaRpcSubscriptions<TCluster>(\n    urlOrMoniker.toString() as TCluster,\n    rpcSubscriptionsConfig,\n  );\n\n  return {\n    rpc,\n    rpcSubscriptions,\n    sendAndConfirmTransaction: sendAndConfirmTransactionWithSignersFactory({\n      // @ts-ignore - TODO(FIXME:nick)\n      rpc,\n      // @ts-ignore - TODO(FIXME:nick)\n      rpcSubscriptions,\n    }),\n    // @ts-ignore\n    simulateTransaction: simulateTransactionFactory({ rpc }),\n  };\n}\n","/**\n * Calculate the total rent needed for to create an account, with or without extra data stored in it\n */\nexport function getMinimumBalanceForRentExemption(space: bigint | number = 0) {\n  /**\n   * Default values for Rent calculations\n   *\n   * Values taken from: https://github.com/anza-xyz/solana-sdk/blob/c07f692e41d757057c8700211a9300cdcd6d33b1/rent/src/lib.rs#L93-L97\n   * \n   */\n  const RENT = {\n    /**\n     * Account storage overhead for calculation of base rent. (aka the number of bytes required to store an account with no data.\n     */\n    ACCOUNT_STORAGE_OVERHEAD: 128n,\n    /**\n     * Amount of time (in years) a balance must include rent for the account to\n     * be rent exempt.\n     */\n    DEFAULT_EXEMPTION_THRESHOLD: BigInt(Math.floor(2.0 * 1000)) / 1000n,\n    /**\n     * Default rental rate in lamports/byte-year. This calculation is based on:\n     * - 10^9 lamports per SOL\n     * - $1 per SOL\n     * - $0.01 per megabyte day\n     * - $3.65 per megabyte year\n     */\n    DEFAULT_LAMPORTS_PER_BYTE_YEAR: BigInt(\n      Math.floor(((1_000_000_000 / 100) * 365) / (1024 * 1024)),\n    ),\n  };\n\n  return (\n    ((RENT.ACCOUNT_STORAGE_OVERHEAD + BigInt(space)) *\n      RENT.DEFAULT_LAMPORTS_PER_BYTE_YEAR *\n      RENT.DEFAULT_EXEMPTION_THRESHOLD) /\n    1n\n  );\n}\n","import { assertKeyExporterIsAvailable, assertKeyGenerationIsAvailable } from \"@solana/assertions\";\nimport type { KeyPairSigner, createKeyPairFromBytes, createKeyPairSignerFromBytes } from \"@solana/kit\";\nimport { createSignerFromKeyPair } from \"@solana/kit\";\n\nexport function assertKeyPairIsExtractable(keyPair: CryptoKeyPair): asserts keyPair is ExtractableCryptoKeyPair {\n  assertKeyExporterIsAvailable();\n\n  if (!keyPair.privateKey) {\n    throw new Error(\"Keypair is missing private key\");\n  }\n\n  if (!keyPair.publicKey) {\n    throw new Error(\"Keypair is missing public key\");\n  }\n\n  if (!keyPair.privateKey.extractable) {\n    throw new Error(\"Private key is not extractable\");\n  }\n}\n\ntype Extractable = { \"~extractable\": true };\n\ntype ExtractableCryptoKeyPair = CryptoKeyPair & Extractable;\ntype ExtractableKeyPairSigner = KeyPairSigner & Extractable;\n\n/**\n * Generates an extractable Ed25519 `CryptoKeyPair` capable of signing messages and transactions\n * */\nexport async function generateExtractableKeyPair(): Promise<ExtractableCryptoKeyPair> {\n  await assertKeyGenerationIsAvailable();\n  return crypto.subtle.generateKey(\n    /* algorithm */ \"Ed25519\", // Native implementation status: https://github.com/WICG/webcrypto-secure-curves/issues/20\n    /* extractable */ true,\n    /* allowed uses */ [\"sign\", \"verify\"],\n  ) as Promise<ExtractableCryptoKeyPair>;\n}\n\n/**\n * Generates an extractable signer capable of signing messages and transactions using a Crypto KeyPair.\n * */\nexport async function generateExtractableKeyPairSigner(): Promise<ExtractableKeyPairSigner> {\n  return createSignerFromKeyPair(await generateExtractableKeyPair()) as Promise<ExtractableKeyPairSigner>;\n}\n\n/**\n * Extracts the raw key material from an extractable Ed25519 CryptoKeyPair.\n *\n * @remarks\n * - Requires a keypair generated with extractable=true. See {@link generateExtractableKeyPair}.\n * - The extracted bytes can be used to reconstruct the `CryptoKeyPair` with {@link createKeyPairFromBytes}.\n *\n * @param keypair An extractable Ed25519 `CryptoKeyPair`\n * @returns Raw key bytes as `Uint8Array`\n */\nexport async function extractBytesFromKeyPair(keypair: ExtractableCryptoKeyPair | CryptoKeyPair): Promise<Uint8Array> {\n  assertKeyPairIsExtractable(keypair);\n\n  const [publicKeyBytes, privateKeyJwk] = await Promise.all([\n    crypto.subtle.exportKey(\"raw\", keypair.publicKey),\n    crypto.subtle.exportKey(\"jwk\", keypair.privateKey),\n  ]);\n\n  if (!privateKeyJwk.d) throw new Error(\"Failed to get private key bytes\");\n\n  return new Uint8Array([...Buffer.from(privateKeyJwk.d, \"base64\"), ...new Uint8Array(publicKeyBytes)]);\n}\n\n/**\n * Extracts the raw key material from an extractable Ed25519 KeyPairSigner.\n *\n * @remarks\n * - Requires a keypair generated with extractable=true. See {@link generateExtractableKeyPairSigner}.\n * - The extracted bytes can be used to reconstruct the `CryptoKeyPair` with {@link createKeyPairSignerFromBytes}.\n *\n * @param keypairSigner An extractable Ed25519 `KeyPairSigner`\n * @returns Raw key bytes as `Uint8Array`\n */\nexport async function extractBytesFromKeyPairSigner(\n  keypairSigner: ExtractableKeyPairSigner | KeyPairSigner,\n): Promise<Uint8Array> {\n  return extractBytesFromKeyPair(keypairSigner.keyPair);\n}\n","import { createKeyPairFromBytes, createSignerFromKeyPair, getBase58Encoder, type KeyPairSigner } from \"@solana/kit\";\n\n/**\n * Create a `CryptoKeyPair` from as base58 encoded secret key\n */\nexport async function createKeypairFromBase58(punitiveSecretKey: string): Promise<CryptoKeyPair> {\n  return createKeyPairFromBytes(getBase58Encoder().encode(punitiveSecretKey));\n}\n\n/**\n * Create a `KeyPairSigner` from as base58 encoded secret key\n */\nexport async function createKeypairSignerFromBase58(punitiveSecretKey: string): Promise<KeyPairSigner> {\n  return createSignerFromKeyPair(await createKeypairFromBase58(punitiveSecretKey));\n}\n","import { getBase64Encoder, getTransactionDecoder, type Transaction } from \"@solana/kit\";\nimport type { transactionToBase64, transactionToBase64WithSigners } from \"./base64-to-transaction\";\n\n/**\n * Convert a base64 encoded transaction string into compiled transaction\n *\n * Use {@link transactionToBase64} or {@link transactionToBase64WithSigners} to create the base64 encoded transaction string\n */\nexport function transactionFromBase64(base64EncodedTransaction: string): Transaction {\n  return getTransactionDecoder().decode(getBase64Encoder().encode(base64EncodedTransaction));\n}\n"]}