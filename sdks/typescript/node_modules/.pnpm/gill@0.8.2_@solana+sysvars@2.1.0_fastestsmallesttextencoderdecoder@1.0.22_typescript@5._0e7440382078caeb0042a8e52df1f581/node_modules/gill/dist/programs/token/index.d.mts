export * from '@solana-program/token-2022';
import { KeyPairSigner, Address, IInstruction, TransactionVersion, TransactionSigner, TransactionMessageWithBlockhashLifetime, ITransactionMessageWithFeePayer } from '@solana/kit';
import { S as Simplify, C as CreateTransactionInput, F as FullTransaction } from '../../index-x1jMRy1Z.mjs';

type TokenInstructionBase<TMint = KeyPairSigner | Address> = {
    /** Signer that will pay for the rent storage deposit fee and transaction fees */
    feePayer: KeyPairSigner;
    /** Token mint to issue the tokens */
    mint: TMint;
    /**
     * Token program used to create the token's `mint`
     *
     * - (default) {@link TOKEN_PROGRAM_ADDRESS} - the original SPL Token Program
     * - {@link TOKEN_2022_PROGRAM_ADDRESS} - the SPL Token Extensions Program (aka Token22)
     **/
    tokenProgram?: Address;
};

type GetCreateTokenInstructionsArgs = TokenInstructionBase<KeyPairSigner> & {
    /**
     * The number of decimal places this token should have
     *
     * @default `9` - the most commonly used decimals value
     **/
    decimals?: bigint | number;
    /**
     * Authority address that is allowed to mint new tokens
     *
     * When not provided, defaults to: `feePayer`
     **/
    mintAuthority?: KeyPairSigner;
    /**
     * Authority address that is able to freeze (and thaw) user owned token accounts.
     * When a user's token account is frozen, they will not be able to transfer their tokens.
     *
     * When not provided, defaults to: `null`
     **/
    freezeAuthority?: Address | KeyPairSigner;
    /**
     * Authority address that is allowed to update the metadata
     *
     * When not provided, defaults to: `feePayer`
     **/
    updateAuthority?: KeyPairSigner;
    /**
     * Optional (but highly recommended) metadata to attach to this token
     */
    metadata: {
        /** Name of this token */
        name: string;
        /** Symbol for this token */
        symbol: string;
        /** URI pointing to additional metadata for this token. Typically an offchain json file. */
        uri: string;
        /** Whether or not the onchain metadata will be editable after minting */
        isMutable: boolean;
    };
    /**
     * Metadata address for this token
     *
     * @example
     * For `TOKEN_PROGRAM_ADDRESS` use the {@link getTokenMetadataAddress} function:
     * ```
     * metadataAddress: await getTokenMetadataAddress(mint.address);
     * ```
     *
     * @example
     * For `TOKEN_2022_PROGRAM_ADDRESS` use the mint's address:
     * ```
     * metadataAddress: mint.address;
     * ```
     * */
    metadataAddress: Address;
};
/**
 * Create the instructions required to initialize a new token's mint
 */
declare function getCreateTokenInstructions(args: GetCreateTokenInstructionsArgs): IInstruction[];

type GetMintTokensInstructionsArgs = TokenInstructionBase<KeyPairSigner | Address> & {
    /**
     * The authority address capable of authorizing minting of new tokens.
     *
     * - this should normally by a `KeyPairSigner`
     * - only for multi-sig authorities (like Squads Protocol), should you supply an `Address`
     * */
    mintAuthority: KeyPairSigner | Address;
    /** Wallet address to receive the tokens being minted, via their associated token account (ata) */
    destination: KeyPairSigner | Address;
    /**
     * Associated token account (ata) address for `destination` and this `mint`
     *
     * See {@link getAssociatedTokenAccountAddress}
     *
     * @example
     * ```
     * getAssociatedTokenAccountAddress(mint, destination, tokenProgram);
     * ```
     * */
    ata: Address;
    /** Amount of tokens to mint to the `owner` via their `ata` */
    amount: bigint | number;
};
/**
 * Create the instructions required to mint tokens to any wallet/owner,
 * including creating their ATA if it does not exist
 *
 * @example
 *
 * ```
 * const mint = await generateKeyPairSigner();
 * const destination = address("nicktrLHhYzLmoVbuZQzHUTicd2sfP571orwo9jfc8c");
 *
 * const instructions = getMintTokensInstructions({
 *   mint,
 *   feePayer: signer,
 *   mintAuthority: signer,
 *   amount: 1000, // note: be sure to consider the mint's `decimals` value
 *   // if decimals=2 => this will mint 10.00 tokens
 *   // if decimals=4 => this will mint 0.100 tokens
 *   destination,
 *   // be sure to set the correct token program when getting the `ata`
 *   ata: await getAssociatedTokenAccountAddress(mint, destination, tokenProgram),
 *   // tokenProgram: TOKEN_PROGRAM_ADDRESS, // default
 *   // tokenProgram: TOKEN_2022_PROGRAM_ADDRESS,
 * });
 * ```
 */
declare function getMintTokensInstructions(args: GetMintTokensInstructionsArgs): IInstruction[];

type GetTransferTokensInstructionsArgs = TokenInstructionBase<KeyPairSigner | Address> & {
    /**
     * The source account's owner/delegate or its multi-signature account:
     * - this should normally by a `KeyPairSigner`
     * - only for multi-sig authorities (like Squads Protocol), should you supply an `Address`
     * */
    authority: KeyPairSigner | Address;
    /**
     * Associated token account (ata) address for `authority` and this `mint`
     *
     * See {@link getAssociatedTokenAccountAddress}
     *
     * @example
     * ```
     * getAssociatedTokenAccountAddress(mint, authority, tokenProgram);
     * ```
     * */
    sourceAta: Address;
    /** Wallet address to receive the tokens, via their associated token account: `destinationAta` */
    destination: KeyPairSigner | Address;
    /**
     * Associated token account (ata) address for `destination` and this `mint`
     *
     * See {@link getAssociatedTokenAccountAddress}
     *
     * @example
     * ```
     * getAssociatedTokenAccountAddress(mint, destination, tokenProgram);
     * ```
     * */
    destinationAta: Address;
    /** Amount of tokens to be transferred to the `destination` via their `destinationAta` */
    amount: bigint | number;
};
/**
 * Create the instructions required to transfer tokens from one wallet to another,
 * including creating the destination ATA if it does not exist
 *
 * @example
 *
 * ```
 * const sourceAta = await getAssociatedTokenAccountAddress(mint, authority, tokenProgram);
 *
 * const destination = address(...);
 * const destinationAta = await getAssociatedTokenAccountAddress(mint, destination, tokenProgram);
 *
 * const instructions = getTransferTokensInstructions({
 *    feePayer: signer,
 *    mint,
 *    amount: 10,
 *    authority: signer, // the source wallet for the tokens to be transferred
 *    sourceAta, // normally derived from the `authority`
 *    destination,
 *    destinationAta, // derived from the `destination`
 *    tokenProgram,
 * });
 * ```
 */
declare function getTransferTokensInstructions(args: GetTransferTokensInstructionsArgs): IInstruction[];

type TransactionBuilderInput<TVersion extends TransactionVersion = "legacy", TFeePayer extends TransactionSigner = TransactionSigner, TLifetimeConstraint extends TransactionMessageWithBlockhashLifetime["lifetimeConstraint"] | undefined = undefined> = Simplify<Omit<CreateTransactionInput<TVersion, TFeePayer, TLifetimeConstraint>, "version" | "instructions" | "feePayer"> & Partial<Pick<CreateTransactionInput<TVersion, TFeePayer, TLifetimeConstraint>, "version">>>;

type GetCreateTokenTransactionInput$1 = Simplify<Omit<GetCreateTokenInstructionsArgs, "metadataAddress"> & Partial<Pick<GetCreateTokenInstructionsArgs, "metadataAddress">>>;
/**
 * Create a transaction that can create a token with metadata
 *
 * The transaction has the following defaults:
 * - Default `version` = `legacy`
 * - Default `computeUnitLimit`:
 *    - for TOKEN_PROGRAM_ADDRESS => `60_000`
 *    - for TOKEN_2022_PROGRAM_ADDRESS => `10_000`
 *
 * @example
 *
 * ```
 * const mint = await generateKeyPairSigner();
 *
 * const transaction = await buildCreateTokenTransaction({
 *   feePayer: signer,
 *   latestBlockhash,
 *   mint,
 *   metadata: {
 *     name: "Test Token",
 *     symbol: "TEST",
 *     uri: "https://example.com/metadata.json",
 *     isMutable: true,
 *   },
 *   // tokenProgram: TOKEN_PROGRAM_ADDRESS, // default
 *   // tokenProgram: TOKEN_2022_PROGRAM_ADDRESS,
 * });
 * ```
 */
declare function buildCreateTokenTransaction<TVersion extends TransactionVersion = "legacy", TFeePayer extends TransactionSigner = TransactionSigner>(args: TransactionBuilderInput<TVersion, TFeePayer> & GetCreateTokenTransactionInput$1): Promise<FullTransaction<TVersion, ITransactionMessageWithFeePayer>>;
declare function buildCreateTokenTransaction<TVersion extends TransactionVersion = "legacy", TFeePayer extends TransactionSigner = TransactionSigner, TLifetimeConstraint extends TransactionMessageWithBlockhashLifetime["lifetimeConstraint"] = TransactionMessageWithBlockhashLifetime["lifetimeConstraint"]>(args: TransactionBuilderInput<TVersion, TFeePayer, TLifetimeConstraint> & GetCreateTokenTransactionInput$1): Promise<FullTransaction<TVersion, ITransactionMessageWithFeePayer, TransactionMessageWithBlockhashLifetime>>;

type GetCreateTokenTransactionInput = Simplify<Omit<GetMintTokensInstructionsArgs, "ata"> & Partial<Pick<GetMintTokensInstructionsArgs, "ata">>>;
/**
 * Create a transaction that can mint tokens to the desired wallet/owner,
 * including creating their ATA if it does not exist
 *
 * The transaction has the following defaults:
 * - Default `version` = `legacy`
 * - Default `computeUnitLimit` = `31_000`
 *
 * @remarks
 *
 * - minting without creating the ata is generally < 10_000cu
 * - validating the ata onchain during creation results in a ~5000cu fluctuation
 *
 * @example
 * ```
 * const destination = address("nicktrLHhYzLmoVbuZQzHUTicd2sfP571orwo9jfc8c");
 *
 * const mint = address(...);
 * // or mint can be a keypair from a freshly created token
 *
 * const transaction = await buildMintTokensTransaction({
 *   feePayer: signer,
 *   latestBlockhash,
 *   mint,
 *   mintAuthority: signer,
 *   amount: 1000, // note: be sure to consider the mint's `decimals` value
 *   // if decimals=2 => this will mint 10.00 tokens
 *   // if decimals=4 => this will mint 0.100 tokens
 *   destination,
 *   // tokenProgram: TOKEN_PROGRAM_ADDRESS, // default
 *   // tokenProgram: TOKEN_2022_PROGRAM_ADDRESS,
 * });
 * ```
 */
declare function buildMintTokensTransaction<TVersion extends TransactionVersion = "legacy", TFeePayer extends TransactionSigner = TransactionSigner>(args: TransactionBuilderInput<TVersion, TFeePayer> & GetCreateTokenTransactionInput): Promise<FullTransaction<TVersion, ITransactionMessageWithFeePayer>>;
declare function buildMintTokensTransaction<TVersion extends TransactionVersion = "legacy", TFeePayer extends TransactionSigner = TransactionSigner, TLifetimeConstraint extends TransactionMessageWithBlockhashLifetime["lifetimeConstraint"] = TransactionMessageWithBlockhashLifetime["lifetimeConstraint"]>(args: TransactionBuilderInput<TVersion, TFeePayer, TLifetimeConstraint> & GetCreateTokenTransactionInput): Promise<FullTransaction<TVersion, ITransactionMessageWithFeePayer, TransactionMessageWithBlockhashLifetime>>;

type GetTransferTokensTransactionInput = Simplify<Omit<GetTransferTokensInstructionsArgs, "sourceAta" | "destinationAta"> & Partial<Pick<GetTransferTokensInstructionsArgs, "sourceAta" | "destinationAta">>>;
/**
 * Create a transaction that can transfer tokens to the desired wallet/owner,
 * including creating their ATA if it does not exist
 *
 * The transaction has the following defaults:
 * - Default `version` = `legacy`
 * - Default `computeUnitLimit` = `31_000`
 *
 * @remarks
 *
 * - transferring without creating the ata is generally < 10_000cu
 * - validating the ata onchain during creation results in a ~15000cu fluctuation
 *
 * @example
 * ```
 * const destination = address(...);
 *
 * const transferTokensTx = await buildTransferTokensTransaction({
 *   feePayer: signer,
 *   latestBlockhash,
 *   mint,
 *   authority: signer,
 *   amount: 900, // note: be sure to consider the mint's `decimals` value
 *   // if decimals=2 => this will transfer 9.00 tokens
 *   // if decimals=4 => this will transfer 0.090 tokens
 *   destination,
 *   // use the correct token program for the `mint`
 *   tokenProgram, // default=TOKEN_PROGRAM_ADDRESS
 *   // default cu limit set to be optimized, but can be overridden here
 *   // computeUnitLimit?: number,
 *   // obtain from your favorite priority fee api
 *   // computeUnitPrice?: number, // no default set
 * });
 * ```
 */
declare function buildTransferTokensTransaction<TVersion extends TransactionVersion = "legacy", TFeePayer extends TransactionSigner = TransactionSigner>(args: TransactionBuilderInput<TVersion, TFeePayer> & GetTransferTokensTransactionInput): Promise<FullTransaction<TVersion, ITransactionMessageWithFeePayer>>;
declare function buildTransferTokensTransaction<TVersion extends TransactionVersion = "legacy", TFeePayer extends TransactionSigner = TransactionSigner, TLifetimeConstraint extends TransactionMessageWithBlockhashLifetime["lifetimeConstraint"] = TransactionMessageWithBlockhashLifetime["lifetimeConstraint"]>(args: TransactionBuilderInput<TVersion, TFeePayer, TLifetimeConstraint> & GetTransferTokensTransactionInput): Promise<FullTransaction<TVersion, ITransactionMessageWithFeePayer, TransactionMessageWithBlockhashLifetime>>;

type LegacyTokenProgramMonikers = "legacy" | "token";
type TokenExtensionProgramMonikers = "token22" | "tokenExtension" | "tokenExtensions" | "token2022";
type TokenProgramMonikers = LegacyTokenProgramMonikers | TokenExtensionProgramMonikers;
declare const TOKEN_PROGRAM_ADDRESS: Address<"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA">;
/**
 * Derive the associated token account (ata) address for an owner and mint/tokenProgram
 *
 * @argument `mint` - the token mint itself
 * @argument `owner` - destination wallet address to own tokens from `mint`
 * @argument `tokenProgram` - token program that the token `mint` was created with
 *
 * - (default) {@link TOKEN_PROGRAM_ADDRESS} - the original SPL Token Program
 * - {@link TOKEN_2022_PROGRAM_ADDRESS} - the SPL Token Extensions Program (aka Token22)
 */
declare function getAssociatedTokenAccountAddress(mint: Address | KeyPairSigner, owner: Address | KeyPairSigner, tokenProgram?: Address): Promise<Address>;
declare function parseTokenProgramAddressOrMoniker(tokenProgram: Address | TokenProgramMonikers): Address;
declare function assertIsSupportedTokenProgram(tokenProgram: Address): asserts tokenProgram is Address<typeof tokenProgram>;
/**
 * Check the provided program is one of the supported token programs.
 * Including setting the default to {@link TOKEN_PROGRAM_ADDRESS} (the original SPL token program)
 *
 * @example
 * ```
 * args.tokenProgram = checkedTokenProgramAddress(args.tokenProgram);
 * ```
 */
declare function checkedTokenProgramAddress(tokenProgram?: Address | TokenProgramMonikers): Address;

export { type GetCreateTokenInstructionsArgs, type GetMintTokensInstructionsArgs, type GetTransferTokensInstructionsArgs, type LegacyTokenProgramMonikers, TOKEN_PROGRAM_ADDRESS, type TokenExtensionProgramMonikers, type TokenProgramMonikers, assertIsSupportedTokenProgram, buildCreateTokenTransaction, buildMintTokensTransaction, buildTransferTokensTransaction, checkedTokenProgramAddress, getAssociatedTokenAccountAddress, getCreateTokenInstructions, getMintTokensInstructions, getTransferTokensInstructions, parseTokenProgramAddressOrMoniker };
