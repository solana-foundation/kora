import { TransactionVersion, Address, TransactionSigner, TransactionMessageWithBlockhashLifetime, IInstruction, ITransactionMessageWithFeePayer, ITransactionMessageWithFeePayerSigner, BaseTransactionMessage } from '@solana/kit';

type CreateTransactionInput<TVersion extends TransactionVersion, TFeePayer extends Address | TransactionSigner = TransactionSigner, TLifetimeConstraint extends TransactionMessageWithBlockhashLifetime["lifetimeConstraint"] | undefined = undefined> = {
    /**
     * Transaction version
     * - `legacy` is commonly used
     * - `0` is needed for use with Address Lookup Tables
     * */
    version: TVersion;
    /** List of instructions for this transaction */
    instructions: IInstruction[];
    /** Address or Signer that will pay transaction fees */
    feePayer: TFeePayer;
    /**
     * Latest blockhash (aka transaction lifetime) for this transaction to
     * accepted for execution on the Solana network
     * */
    latestBlockhash?: TLifetimeConstraint;
    /** Compute unit limit value to set on this transaction */
    computeUnitLimit?: number | bigint;
    /** Compute unit price (in micro-lamports) to set on this transaction */
    computeUnitPrice?: number | bigint;
};
type FullTransaction<TVersion extends TransactionVersion, TFeePayer extends ITransactionMessageWithFeePayer | ITransactionMessageWithFeePayerSigner, TBlockhashLifetime extends TransactionMessageWithBlockhashLifetime | undefined = undefined> = Simplify<BaseTransactionMessage<TVersion> & TFeePayer & (TBlockhashLifetime extends TransactionMessageWithBlockhashLifetime ? TransactionMessageWithBlockhashLifetime : {})>;

type Simplify<T> = {
    [K in keyof T]: T[K];
} & {};

export type { CreateTransactionInput as C, FullTransaction as F, Simplify as S };
